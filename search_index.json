[["index.html", "Découvrir R et RStudio Chapitre 1 Introduction 1.1 Le parcours de formation 1.2 Objectifs du module 1", " Découvrir R et RStudio Thierry Zorn, Murielle Lethrosne, Vivien Roussez &amp; Pascal Irz 09 December 2020 Chapitre 1 Introduction Crédit photographique Pascal Boulin 1.1 Le parcours de formation Ce dispositif de formation vise à faire monter en compétence les agents du MTES (Ministère de la transition écologique) et du MCTRCT (Ministère de la Cohésion des Territoires et des Relations avec les collectivités territoriales) dans le domaine de la science de la donnée avec le logiciel R. Il est conçu pour être déployé à l’échelle nationale par le réseau des CVRH (Centre de Valorisation des Ressources Humaines). Le parcours proposé est structuré en modules de 2 jours chacun. Les deux premiers (ou un niveau équivalent) sont des pré-requis pour suivre les suivants qui sont proposés “à la carte” : Socle : Premier programme en R Socle : Préparation des données Statistiques descriptives Analyse des données multi-dimensionnelles Datavisualisation : Produire des graphiques, des cartes et des tableaux Publications reproductibles avec RMarkdown (à venir) Analyse spatiale (à venir) Big data et optimisation du code (à venir) Applications interactives avec Shiny (à venir) La mise à disposition des supports de formation se fait désormais par la page d’accueil du parcours de formation. Ces supports sont en licence ouverte. Si vous souhaitez accéder aux sources ou aux données mobilisées pendant les formations, il faut directement les télécharger depuis le Github du ministère. Pour vous tenir au courant de l’offre de formation proposée par le réseau des CVRH, consultez la plateforme OUPS (un accès intranet MTES-MCT est nécessaire). Vous pouvez vous y abonner pour recevoir les annonces de formation qui vous intéressent. Pour échanger de l’information, discuter autour de R ou encore faire part de difficultés et trouver ensemble les solutions, il existe deux solutions: - S’insrire, en envoyant un message vide avec le titre “subscribe labo.communaute-r,” à l’adresse sympa@developpement-durable.gouv.fr. - rejoindre le fil Ariane # utilisateurs_r 1.2 Objectifs du module 1 Ce module vise à faire découvrir : R et son écosystème L’interface de RStudio Les méthodes élémentaires d’importation des données Des premières statistiques Des premières représentations graphiques Il s’agit d’avoir les clefs pour commencer à travailler rapidement sur R en complément, voire en remplacement d’autres outils (Excel, SAS…). Les concepts de programmation sont également abordés pour comprendre les syntaxes proposées dans les différents forums d’aide. "],["r-son-écosystème-et-ses-possibilités.html", "Chapitre 2 R, son écosystème et ses possibilités 2.1 Le groupe de référents 2.2 R c’est quoi ? 2.3 Un peu d’histoire 2.4 Un logiciel libre 2.5 Que peut-on faire avec R ? 2.6 Un logiciel modulaire 2.7 Des exemples de ce qu’on peut faire avec R :", " Chapitre 2 R, son écosystème et ses possibilités 2.1 Le groupe de référents Un groupe pour structurer une offre de formations sur R Un réseau d’entraide 2.2 R c’est quoi ? Un langage de programmation interprété exécutable pas à pas \\(\\rightarrow\\) lignes de code Un logiciel interactif permettant de traiter divers types de données 2.3 Un peu d’histoire À l’origine existait le langage S, servant à programmer avec des données (Bell laboratory, années 70) Au milieu des années 90, mélange de S et du langage Lisp pour le dédier à l’analyse de données et aux graphiques \\(\\rightarrow\\) création de R. Ihaka R, Gentleman R (1996) R: A Language for Data Analysis and Graphics. Journal of Computational and Graphical Statistics, 5(3), 299–314 S’est d’abord développé dans le monde académique, puis a essaimé vers d’autres domaines professionnels, voire associatifs Système toujours d’actualité - Mise à jour tous les 6 mois Avenir dans la statistique publique : adopté comme standard par l’Insee (à l’horizon 2025) et divers SSM. Des packages pour : charger les données produites par l’Insee au format sdmx, charger les formats des organisations internationales (Eurostat, OCDE, ONU, etc.), gérer les millésimes du référentiel communal, etc. 2.4 Un logiciel libre Disponible en libre téléchargement sur le site officiel du CRAN Installable sur la plupart des systèmes d’exploitation Utilisé en recherche, en enseignement et en entreprise Une communauté très active : Forum des utilisateurs de R en français Communauté française des utilisateurs de R (avec des packages spécifiques, qui permettent de gérer les changements de géographie communale par exemple) : Frrrenchies Slack de ces utilisateurs (pour les questions/réponses, actualités…) Slack Forum des utilisateurs de R en français : http://forums.cirad.fr/logiciel-R/ R-bloggers : https://www.r-bloggers.com/ Stackoverflow : https://stackoverflow.com/questions/tagged/r C’est un logiciel libre : les utilisateurs ont la liberté d’exécuter, copier, distribuer, étudier, modifier et améliorer ce logiciel. R fait partie de la “galaxie” GNU (GNU’s Not Unix). R est donc libre, gratuit et multiplateforme. Le site CRAN = Comprehensive R Archive Network est le site de référence pour R. Il contient non seulement les installeurs du logiciel mais également de nombreuses ressources : documentations, FAQ, tutoriels… 2.5 Que peut-on faire avec R ? Lire des données de formats divers Les manipuler (prétraitements) Les enrichir à partir de données externes Les analyser, les modéliser Présenter les résultats (tableaux, graphiques, cartes) Publier … … et ce au moyen d’une palette de méthodes extrêmement diversifiée. Privilégie la flexibilité et le découpage des traitements en parties simples. 2.6 Un logiciel modulaire Le package base contient nombreuses fonctionnalités Extensible au moyen de packages (1 package = 1 ensemble de nouvelles fonctions) Nombreuses extensions spécialisées Proposition d’une version installable de R + ensemble de packages utiles De base, R permet déjà de faire un très grand nombre de choses avec son socle commun : le package base. Pour afficher la liste des fonctions disponibles dans le package base : library(help = &#39;base&#39;) Sur ce package base vient se greffer un ensemble de packages (plugins, modules) complémentaires. Un package est une bibliothèque de fonctions. La plupart de ceux qui font référence sont mis à disposition de tous sur le dépôt CRAN. Cela permet d’étendre à l’infini les possibilités de R : celles-ci sont seulement limitées par la volonté de développement des utilisateurs. De même que les packages sont dépendants de fonctions du module principal base, certains packages peuvent être dépendants de fonctionnalités d’autres packages \\(\\rightarrow\\) notion d’arbre des dépendances (géré par R de façon transparente). Sructure modulaire \\(\\rightarrow\\) il existe de multiple façons d’effectuer une même tâche. Il suffit d’une méthode maîtrisée pour aller au résultat. Les fonctionnalités utilisables dans R, sont en perpétuelle évolution et permettent d’intégrer les méthodes les plus récentes dans des domaines qui évoluent rapidement : modélisation, analyse spatiale, dataviz,… Le groupe des référents propose un pack d’installation comprenant R, RStudio et un ensemble de packages en phase avec le parcours de formation. Vous pouvez le télécharger ici en deux fichiers compressés (nécessite un accès intranet MTES-MCT). 2.7 Des exemples de ce qu’on peut faire avec R : Le support de cette formation Visualisation du compte du logement Les pesticides dans les cours d’eau des Pays de la Loire Des exemples de ce qu’on peut faire avec shiny "],["présentation-de-linterface-et-premières-manipulations.html", "Chapitre 3 Présentation de l’interface et premières manipulations 3.1 Une interface dédiée : RStudio 3.2 Session et répertoire de travail 3.3 Exercice 3.4 Prise en main de la console 3.5 Création d’une variable 3.6 Exercice 3.7 Utilité des scripts 3.8 Exercice : utiliser un script", " Chapitre 3 Présentation de l’interface et premières manipulations Ce chapitre permet de découvrir l’interface de travail RStudio et les principales fonctionnalités pour débuter. 3.1 Une interface dédiée : RStudio Environnement de développement conçu spécialement pour R Interface utilisateur simple, conviviale, configurable et intégrant plusieurs outils Disponible sur http://www.rstudio.com L’interface RStudio est composée de différents panneaux, dont l’arrangement peut être reconfiguré, incluant une console, un navigateur de fichiers et graphiques, l’espace de travail et l’historique des commandes. D’autres environnements graphiques existent, Rstudio semble le plus approprié à nos métiers Lancer le script exemple Démonstration : “./Presentation RStudio” 3.2 Session et répertoire de travail Session de travail R : commence à l’ouverture de RStudio et se termine en le quittant Répertoire de travail R : Dossier dans lequel le logiciel va chercher les fichiers de scripts et de données Tout ce qui a été fait au cours d’une session peut être enregistré dans le répertoire de travail : données historique des fonctions … Nouvelles fonctions Attention setwd() pour définir un répertoire de travail Seulement / et pas \\ help() et ? pour afficher l’aide . dir() pour lister un répertoire . Attention avec le répertoire de travail : si on l’écrit en dur setwd('...'), les anti-slash windows (\\) doivent être remplacés par des slash(/) Concernant le répertoire de travail, quelques conseils : Créer un nouveau répertoire pour un projet particulier qui sera votre répertoire de travail Créer des sous-répertoires dans ce répertoire : “./Data,” “./Figures,” “./Redaction”… Rassembler autant que possible les fichiers qui seront utilisés dans le cadre de ce projet et éviter d’aller chercher des fichiers ailleurs 3.3 Exercice Sur le poste de travail, créer un dossier devant servir de dossier de travail au cours de la formation. Dans Rstudio, définir ce dossier comme répertoire de travail directement en utilisant setwd('') Appeler l’aide en ligne par ?setwd ou help(setwd) Faire une recherche dans la partie Help de RStudio Lire le contenu du répertoire de travail avec dir() 3.4 Prise en main de la console Effectuer et afficher les résultats de calculs de base (+, -, *, /, ^, ...) Utiliser des fonctions spécifiques : sum, abs, round… On peut remonter dans l’historique des fonctions pour en rappeler une Nouvelles fonctions Attention sum() pour sommer un résultat Séparateur décimal point (.) abs() pour retourner la valeur absolue . round() pour arrondir un nombre . flèches pour naviguer dans l’historique . 3.5 Création d’une variable On assigne un contenu à une variable au moyen de &lt;- ma_variable &lt;- 2 ma_variable &lt;- &quot;Toulouse&quot; ma_variable &lt;- c(&quot;Toulouse&quot;, &quot;Nantes&quot;, &quot;Strasbourg&quot;) ma_variable &lt;- 1:10 \\(\\rightarrow\\) Les variables peuvent être numérique, texte ou boléen (TRUE/FALSE) et elles peuvent être réutilisées. Nouvelles fonctions Attention pour le nommage des variables ls() pour faire lister les variables existantes Casse -&gt; seulement minuscules paste() pour concaténer des variables textes Pas de caractères spéciaux ni accentués rm() pour supprimer une variable Pas d’espaces ni tirets (-) ; préférer (_) Adopter des règles de nommage cohérentes, par exemples celles-ci. 3.6 Exercice Créer plusieurs variables numériques par assignation a &lt;- 5, b &lt;- 4 Regarder l’onglet Environnement Afficher la liste des variables avec la fonction ls() Faire un calcul avec ces variables et voir le résultat (a+b) etc. Créer une troisième variable à partir des deux premières c &lt;- a+b*3 Ré-assigner une variable : a&lt;-10 et vérifier l’onglet environnement Créer une variable chaîne de caractère (utilisation des simples quotes et des double-quotes) t &lt;- 'chaine' Concaténer a et t avec paste(a,t) Expérimenter la casse des noms de variables : créer A &lt;- 15 et B &lt;- 12 et vérifier l’onglet environnement Supprimer les variables A et B avec la fonction rm() Aide en ligne ?ls et ?rm Attention : Pour supprimer toutes les variables rm(list = ls()) 3.7 Utilité des scripts Garder la trace d’une longue succession de lignes de code Pouvoir exécuter ce code (pas à pas ou en entier) Le modifier plus rapidement pour l’adapter Pouvoir le réutiliser avec de nouvelles données Nouvelles fonctions Attention # pour des commentaires explicatifs du code Importance de bien commenter print() pour afficher sur la console . Ctrl+Entrée pour lancer un script ligne par ligne . Utilisation simple de R \\(\\rightarrow\\) mode console. Chaque ordre, bout de code est rentré et exécuté au fur et à mesure sur la console. Actions plus complexes, longues, nécessitant une maintenance, des modifications \\(\\rightarrow\\) travailler à partir de la fenêtre éditeur. Les parties de code sont enchaînées et enregistrées sous la forme d’un fichier texte réutilisable par la suite. Toujours utiliser des commentaires. Permet de pouvoir mieux comprendre ce que l’on a fait lorsqu’on reprend un programme plus tard ou lorsqu’on le donne à quelqu’un. 3.8 Exercice : utiliser un script Recopier le script ci-dessous et changer les paramètres pour le re-exécuter plusieurs fois Sauvegarder ce script dans votre répertoire de travail Fermer RStudio, le rouvrir, et réexécuter le script # Supprimer toutes les variables existantes rm(list = ls()) # Création de mes variables taille et poids ; attention au point décimal poids &lt;- 91 taille &lt;- 1.87 # Calcul de l&#39;IMC : poids sur taille au carré imc &lt;- poids / (taille ^ 2) # Affichage du résultat print (imc) ## [1] 26.02305 "],["mon-premier-jeu-de-données.html", "Chapitre 4 Mon premier jeu de données 4.1 Les types de valeurs dans R 4.2 Avant de manipuler le dataframe : installer et charger un package 4.3 Importation de données 4.4 Structure des données : le dataframe 4.5 Gérer le type des variables 4.6 Les valeurs particulières 4.7 Exercice : Importer les données et premier coup d’oeil", " Chapitre 4 Mon premier jeu de données 4.1 Les types de valeurs dans R Une valeur constitue l’unité de base des données pour R. Comme pour la plupart des logiciels, elles peuvent être de trois types : Numérique : entier, double Caractère : texte ou code Logique : booléens Ces valeurs sont ensuites structurées au sein de vecteurs qui sont compilés dans des dataframes. 4.2 Avant de manipuler le dataframe : installer et charger un package Pour manipuler notre base de données, nous allons nous servir de fonctionnalités présentes dans le package tidyverse. La première fois que l’on veut utiliser un package, il faut le télécharger sur notre ordinateur, avec install.packages() : install.packages(&quot;tidyverse&quot;) Puis à l’ouverture d’une session R, le charger (si on a besoin de ses fonctions), avec library() : library(&quot;tidyverse&quot;) Le package est prêt à être utilisé ! 4.3 Importation de données Conseil : exporter les données au format CSV ; c’est le format le plus interopérable (supporté par tous les logiciels stat). Utiliser ensuite la fonction read.csv après avoir défini le répertoire de travail (ou en donnant le chemin complet) base &lt;- read.csv (file = &quot;data/Base_synth_territoires.csv&quot;, header = T, sep = &quot;;&quot;, dec = &quot;,&quot;) header =indique la présence des noms de variable sur la première ligne sep = indique le séparateur de champ : ‘;’ ‘/t’ pour tabulation. dec = indique le séparateur de décimale (‘.’ par défaut) colClasses =permet de préciser le type de la données en entrée \\(\\Rightarrow\\) ?read.csv pour plus d’options Autres façons d’importer les données Fonction read_delim, du package readr, plus rapide Fonction fread, du package data.table, beaucoup plus rapide !! Pour importer les fichiers XLS, ODT ou DBF, il existe des fonctions et des packages spécifiques Le passage par un fichier csv est très recommandé 4.4 Structure des données : le dataframe n lignes (observations) p colonnes (variables) nrow (base) ## [1] 36689 ncol (base) ## [1] 38 dim (base) ## [1] 36689 38 4.5 Gérer le type des variables À chaque type de variable (numéric, factor,…) correspond une utilisation. Lors de l’import des données, un type est affecté automatiquement par R. Mais le type peut être erronné. Il suffit alors de les convertir : base &lt;- mutate(base, LIBGEO = as.character (LIBGEO)) ou as.factor(), as.numeric(), etc… Pour être sûr de ne pas faire de bêtise, il vaut mieux gérer les types au moment de l’importation avec le paramètre colClasses \\(\\rightarrow\\) exercice ! 4.6 Les valeurs particulières NA : Valeur manquante (Not Available) NaN : Pas un nombre (Not a Number, e.g., 0/0) -Inf, Inf : Inﬁni positif ou négatif, e.g. 1/0 V1 &lt;- c(1, 14, NA, 32.7) mean(V1) # renvoie NA. Not good ! ## [1] NA mean(V1, na.rm = T) # renvoie 15.9 - OK ! ## [1] 15.9 \\(\\Rightarrow\\) Le module 2 “Préparation des données” aborde la gestion de ces valeurs particulières. 4.7 Exercice : Importer les données et premier coup d’oeil On peut importer n’importe quel format de données en R (Excel, SAT, Stata, SQL…). Beaucoup sont abordés lors du module 2 “Préparation des données”. Pour ce module, nous ne voyons que l’importation de fichier .CSV. Si vous avez une base de données en Excel ou LibreOffice Calc, sauvegardez l’onglet que vous souhaitez en faisant “enregistrer sous” \\(\\rightarrow\\) “délimité CSV.” Ici, nous travaillerons sur une base de données communales fournie par l’Insee, dite “comparateur de territoires.” Le fichier source (Excel) figure dans le sous-répertoire “data” et contient toutes les métadonnées. Utiliser la fonction read.csv() pour importer ce fichier et stocker le dans un objet df. Veillez à ce que la région soit bien importée comme un facteur et non un entier. Inspecter le dataframe avec les fonctions vues auparavant df &lt;- read.csv(file = &quot;data/Base_synth_territoires.csv&quot;, sep = &quot;;&quot;, dec = &quot;,&quot;, colClasses = c(NA, &quot;NULL&quot;, &quot;character&quot;, &quot;NULL&quot;,&quot;NULL&quot;,&quot;NULL&quot;, NA, NA, NA, NA, rep(&quot;NULL&quot;, 28))) str(df) ## &#39;data.frame&#39;: 36689 obs. of 6 variables: ## $ CODGEO : chr &quot;01001&quot; &quot;01002&quot; &quot;01004&quot; &quot;01005&quot; ... ## $ REG : chr &quot;84&quot; &quot;84&quot; &quot;84&quot; &quot;84&quot; ... ## $ P14_POP : int 767 239 14022 1627 109 2570 743 338 1142 397 ... ## $ P09_POP : int 787 207 13350 1592 120 2328 660 336 960 352 ... ## $ SUPERF : num 15.95 9.15 24.6 15.92 5.88 ... ## $ NAIS0914: int 40 16 1051 117 8 175 59 12 56 25 ... On peut également gérer les problèmes d’encodage de caractères (si on passe de Windows à un système Unix, par exemple). head(df) ## CODGEO REG P14_POP P09_POP SUPERF NAIS0914 ## 1 01001 84 767 787 15.95 40 ## 2 01002 84 239 207 9.15 16 ## 3 01004 84 14022 13350 24.60 1051 ## 4 01005 84 1627 1592 15.92 117 ## 5 01006 84 109 120 5.88 8 ## 6 01007 84 2570 2328 33.55 175 tail(df) ## CODGEO REG P14_POP P09_POP SUPERF NAIS0914 ## 36684 97419 04 6722 6822 177.60 519 ## 36685 97420 04 22406 22437 57.84 1963 ## 36686 97421 04 7132 7406 103.82 661 ## 36687 97422 04 76796 72658 165.43 6663 ## 36688 97423 04 7198 7057 42.58 531 ## 36689 97424 04 5295 5989 84.40 430 names(df) ## [1] &quot;CODGEO&quot; &quot;REG&quot; &quot;P14_POP&quot; &quot;P09_POP&quot; &quot;SUPERF&quot; &quot;NAIS0914&quot; class(df) # la classe de l&#39;objet (du point de vue langage orienté objet) ## [1] &quot;data.frame&quot; typeof(df) # le type d&#39;objet du point de vue &quot;interne&quot; à R ## [1] &quot;list&quot; # Accéder a une variable directement (on obtient un vecteur), grâce à $ : df$CODGEO[1:10] # Captain crochet poweeeeerr !!! ## [1] &quot;01001&quot; &quot;01002&quot; &quot;01004&quot; &quot;01005&quot; &quot;01006&quot; &quot;01007&quot; &quot;01008&quot; &quot;01009&quot; &quot;01010&quot; ## [10] &quot;01011&quot; class(df$CODGEO) ## [1] &quot;character&quot; typeof(df$CODGEO) ## [1] &quot;character&quot; length(df) ## [1] 6 length(df$REG) ## [1] 36689 "],["bien-commencer.html", "Chapitre 5 Bien commencer 5.1 Créer un projet sous Rstudio pour vous permettre de recenser vos travaux. 5.2 Intégrer vos données 5.3 Créer votre arborescence de projet 5.4 Activer les packages nécessaires 5.5 Bien structurer ses projets data", " Chapitre 5 Bien commencer 5.1 Créer un projet sous Rstudio pour vous permettre de recenser vos travaux. Pourquoi travailler avec les projets Rstudio plutôt que les scripts R ? Cela permet la portabilité : le répertoire de travail par défaut d’un projet est le répertoire où est ce projet. Si vous transmettez celui-ci à un collègue, le fait de lancer un programme ne dépend pas de l’arborescence de votre machine. Fini les setwd(\"chemin/qui/marche/uniquement/sur/mon/poste\") ! Toujours sur la portabilité, un projet peut être utilisé avec un outil comme packrat qui va vous intégrer en interne au projet l’ensemble des packages nécessaires au projet. Cela permet donc à votre collègue à qui vous passez votre projet de ne pas avoir à les installer et, surtout, si vous mettez à jour votre environnement R, votre projet restera toujours avec les versions des packages avec lesquelles vous avez fait tourner votre projet à l’époque. Cela évite d’avoir à subir les effets d’une mise à jour importante d’un package qui casserait votre code. Pour activer packrat sur un projet, aller dans Tools/Project Options-&gt;Packrat En savoir plus sur Packrat Cela permet de se forcer à travailler en mode projet : on intègre à un seul endroit tout ce qui est lié à un projet : données brutes, données retravaillées, scripts, illustrations, documentations, publications… et donc y compris les packages avec packrat. On peut travailler sur plusieurs projets en même temps, Rstudio ouvre autant de sessions que de projets dans ce cas. Les projets Rstudio intègrent une interface avec les outils de gestion de version Git et SVN. Cela veut dire que vous pouvez versionniser votre projet et l’héberger simplement comme répertoire sur des plateformes de gestion de code telle que Github ou Gitlab. Pour créer un projet : Cliquez sur Project en haut à droite puis New Project. Cliquez sur New Directory. 5.2 Intégrer vos données Une bonne pratique est de créer un sous répertoire /data pour stocker les données sur lesquelles vous aurez à travailler. Vous pouvez le faire depuis l’explorateur de fichier de votre système d’exploitation ou directement à partir de l’explorateur de fichier de RStudio. Cela marche bien quand on a un seul type de données, mais en général on va avoir à travailler sur des données brutes que l’on va retravailler ensuite et vouloir stocker à part. Si par la suite vous souhaitez avoir des exemples de bonnes pratiques sur comment structurer vos données, vous pouvez vous référer au chapitre data du livre d’Hadley Wickham sur la construction de packages R (tout package R étant aussi un projet !). 5.3 Créer votre arborescence de projet Créer un répertoire /src ou vous mettrez vos scripts R. Créer un répertoire /figures ou vous mettrez vos illustrations issues de R. 5.4 Activer les packages nécessaires Commencer par rajouter un script dans le répertoire /src à votre projet qui commencera par : activer l’ensemble des packages nécessaires (pour la formation, un script permet d’installer tous les packages nécessaires) charger les données dont vous aurez besoin. library(tidyverse) library(GGally) library(plotly) base &lt;- read.csv (file = &quot;data/Base_synth_territoires.csv&quot;, header = T, sep = &quot;;&quot;, dec = &quot;,&quot;) 5.5 Bien structurer ses projets data Plusieurs documents peuvent vous inspirer sur la structuration de vos projets data par la suite. En voici quelques uns : https://github.com/pavopax/new-project-template https://nicercode.github.io/blog/2013-04-05-projects/ https://www.inwt-statistics.com/read-blog/a-meaningful-file-structure-for-r-projects.html http://projecttemplate.net/architecture.html À partir du moment où quelques grands principes sont respectés (un répertoire pour les données brutes en lecture seule par exemple), le reste est surtout une question d’attirance plus forte pour l’une ou l’autre solution. L’important est de vous tenir ensuite à conserver toujours la même arborescence dans vos projets afin de vous y retrouver plus simplement. "],["première-manipulation-des-données.html", "Chapitre 6 Première manipulation des données 6.1 Afficher les valeurs et manipuler les variables 6.2 Créer de nouvelles variables 6.3 Sélectionner des variables 6.4 Filtrer des observations 6.5 Les tests logiques dans R 6.6 Renommer des colonnes 6.7 Exercice : Créer, filtrer, sélectionner", " Chapitre 6 Première manipulation des données require(&quot;dplyr&quot;) 6.1 Afficher les valeurs et manipuler les variables Pour afficher la table, plusieurs façons : “clic” dans l’environnement Rstudio, View(base), print(base), base. Pour accéder à une variable : fonction pull() Par exemple : str(pull(base, DEP)) ## chr [1:36689] &quot;01&quot; &quot;01&quot; &quot;01&quot; &quot;01&quot; &quot;01&quot; &quot;01&quot; &quot;01&quot; &quot;01&quot; &quot;01&quot; &quot;01&quot; &quot;01&quot; &quot;01&quot; ... 6.2 Créer de nouvelles variables La fonction mutate() permet de créer/modifier une variable (ou plusieurs). TableEnSortie &lt;- mutate(TableEnEntree, NouvelleVariable = DefinitionDeLaVariable) Par exemple : base &lt;- mutate(base, log_SUPERF = log(SUPERF)) Nb : mutate() permet également de modifier une variable. Dans ce cas la syntaxe est la même que ci-dessus, mais les noms d’entrée et de sortie sont les mêmes : base &lt;- mutate(base, log_SUPERF = 100 * log_SUPERF) \\(\\Rightarrow\\) La table base contient de nouvelles colonnes 6.3 Sélectionner des variables La fonction select() permet de sélectionner les variables voulues. sélection par liste blanche TableEnSortie &lt;- select(TableEnEntree, Variable1, Variable2, ..., VariableN) sélection par liste noire (supprimer) TableEnSortie &lt;- select(TableEnEntree, -Variable1, -Variable2, ..., -VariableN) Par exemple : base_select &lt;- select(base, CODGEO, LIBGEO, P14_POP) base_select &lt;- select(base, -CODGEO) 6.4 Filtrer des observations La fonction filter() permet de sélectionner les observations, selon une condition (ou plusieurs). TableEnSortie &lt;- filter(TableEnSortie, Condition1, ..., ConditionN) Par exemple : base_filter &lt;- filter(base, DEP == &quot;01&quot; &amp; P14_POP &gt; 10000) \\(\\Rightarrow\\) Attention à l’opérateur de comparaison : \" == \" et non pas “=” 6.5 Les tests logiques dans R Syntaxe Action == Test d’égalité != Différent de %in% c(…) Dans une liste de valeurs \\(&gt;, &gt;=\\) \\(&lt;, &lt;=\\) Supérieur (ou inférieur) (ou égal) ! (x %in% c(…)) N’est pas dans une liste de valeurs TableEnSortie &lt;- filter(TableEnSortie, x==a &amp; y==b) # x vaut a **ET** y vaut b TableEnSortie &lt;- filter(TableEnSortie, x==a | y==b) # x vaut a **OU** y vaut b (barre verticale AltGR+6) 6.6 Renommer des colonnes La fonction rename() permet de renommer une variable (ou plusieurs). base &lt;- rename(base, nouveau_nom = ancien_nom) Exemple base_rename &lt;- rename(base, ZONE_EMPLOI = ZE) 6.7 Exercice : Créer, filtrer, sélectionner En utilisant la fonction mutate(), créer une nouvelle variable correspondant à la densité de population (rapport de la population à la superficie de la commune), ainsi que les taux de natalité et de mortalité (en pour mille) A l’aide de la fonction select(), créer une nouvelle table en ne conservant que le code commune, le type de commune (ZAU), la région, le département et les variables que vous venez de créer. Enfin, ne conserver les communes correspondant à votre département de naissance et stocker ce dataframe. Attention au type de la variable département ! Avec les opérateurs logiques, faire des essais pour sélectionner des échantillons différents. df &lt;- mutate(base, densite = P14_POP / SUPERF, tx_natal = 1000 * NAISD15 / P14_POP, tx_mort = DECESD15 / P14_POP) selection &lt;- select(df, CODGEO, ZAU, REG, DEP, densite, tx_natal, tx_mort) S0 &lt;- filter(selection, DEP == &quot;62&quot;) S1 &lt;- filter(selection, DEP != &quot;62&quot;) # tout sauf le 62 :( S2 &lt;- filter(selection, DEP %in% c(&quot;59&quot;, &quot;62&quot;)) # L&#39;ancien NPdC :) S3 &lt;- filter(selection, !(DEP %in% c(&quot;59&quot;, &quot;62&quot;))) # Le &quot;sud&quot; de la France S4 &lt;- filter(selection, densite &gt; 100) # l&#39;urbain S5 &lt;- filter(selection, DEP == &quot;62&quot; &amp; densite &gt; 100) # le PdC urbain S6 &lt;- filter(selection, DEP == &quot;62&quot; | densite &gt; 100) # le PdC et l&#39;urbain Nom d’un pipe %&gt;% ! On peut combiner les opérations en une seule ligne à l’aide du pipe %&gt;% : selection_62 &lt;- select(df, CODGEO, ZAU, REG, DEP, densite, tx_natal) %&gt;% filter(DEP == &quot;62&quot;) "],["premiers-traitements-statistiques.html", "Chapitre 7 Premiers traitements statistiques 7.1 Obtenir des informations 7.2 Calculer des statistiques spécifiques 7.3 Agréger des données 7.4 Tableau de contingence 7.5 Tableau de proportions 7.6 Exercice : calcul de statistiques", " Chapitre 7 Premiers traitements statistiques 7.1 Obtenir des informations La fonction summary() peut s’appliquer à une table entière ou un vecteur. Appliquée sur un tableau, elle donne les statistiques principales sur chacune des variables, en s’adaptant au type de celles-ci (numerique ou texte). base_extrait &lt;- base %&gt;% select(1, 3, 5, 7:12) summary(base_extrait) ## CODGEO REG ZAU P14_POP ## Length:36689 Min. : 1.00 Length:36689 Min. : 0 ## Class :character 1st Qu.:28.00 Class :character 1st Qu.: 197 ## Mode :character Median :44.00 Mode :character Median : 444 ## Mean :52.05 Mean : 1838 ## 3rd Qu.:76.00 3rd Qu.: 1110 ## Max. :94.00 Max. :2220445 ## NA&#39;s :821 ## P09_POP SUPERF NAIS0914 DECE0914 ## Min. : 0 Min. : 0.04 Min. : 0.0 Min. : 0.00 ## 1st Qu.: 193 1st Qu.: 6.44 1st Qu.: 9.0 1st Qu.: 8.00 ## Median : 431 Median : 10.81 Median : 23.0 Median : 17.00 ## Mean : 1793 Mean : 17.64 Mean : 114.4 Mean : 77.35 ## 3rd Qu.: 1072 3rd Qu.: 18.58 3rd Qu.: 60.0 3rd Qu.: 43.00 ## Max. :2234105 Max. :18360.00 Max. :150843.0 Max. :69907.00 ## NA&#39;s :821 NA&#39;s :821 NA&#39;s :821 NA&#39;s :821 ## P14_MEN ## Min. : 0.0 ## 1st Qu.: 83.8 ## Median : 183.2 ## Mean : 802.0 ## 3rd Qu.: 454.9 ## Max. :1147990.9 ## NA&#39;s :821 Les variables quantitatives summary(pull(base_extrait, NAIS0914)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 0.0 9.0 23.0 114.4 60.0 150843.0 821 Les variables qualitatives summary(pull(base_extrait, ZAU)) ## Length Class Mode ## 36689 character character 7.2 Calculer des statistiques spécifiques Les fonctions sum(), mean(), median(), min(), max(), var(), sd()… résument l’information pour en donner une statistique. La fonction quantile() renvoie les quartiles de la variables (ou bien tout autre découpage qu’on lui renseigne). sum(pull(base_extrait, P14_POP), na.rm = T) ## [1] 65907160 mean(pull(base_extrait, P14_POP), na.rm = T) ## [1] 1837.492 median(pull(base_extrait, P14_POP), na.rm = T) ## [1] 444 quantile(pull(base_extrait, P14_POP), probs = c(0.25, 0.5, 0.75), na.rm = T) ## 25% 50% 75% ## 197 444 1110 Ces fonctions retournent une valeur, ou bien un ensemble de valeur (pour quantile()). Le résultat est donc un vecteur de un ou plusieurs nombres. 7.3 Agréger des données 7.3.1 Globalement La fonction summarise() permet d’aggréger des données, en appliquant une fonction sur les variables pour construire une statistique sur les observations de la table. C’est une fonction dite de “résumé.” summarise (TableEnEntree, NomVariableAgregee = Fonction(NomVariableEtude)) base_med &lt;- base_extrait %&gt;% summarise(population_med = median(P14_POP, na.rm = T)) La fonction summarise() retourne un data.frame. 7.3.2 Selon un facteur La fonction summarise() couplée à group_by() permet de calculer des statistiques pour chaque modalité d’une variable qualitative. Avec group_by(), on précise les variables qui formeront des groupes, sur lesquels on appliquera une fonction : TableauGroupes &lt;- group_by (TableEnEntree, Variable1, ..., VariableN) summarise (TableauGroupes, NomVariableAgregee = Fonction (NomVariableEtude)) Par exemple, si on veut avoir la médiane de la variable P14_POP, pour chaque ZAU et chaque région : base_reg_ann &lt;- base_extrait %&gt;% group_by (ZAU, REG) %&gt;% summarise (population_med = median (P14_POP, na.rm = T)) 7.4 Tableau de contingence La fonction table() calcule les effectifs d’un tableau croisé : t &lt;- base_extrait %&gt;% select(ZAU, REG) %&gt;% table print(t) ## REG ## ZAU 1 2 3 4 11 ## 111 - Grand p\\xf4le (plus de 10 000 emplois) 17 16 3 10 413 ## 112 - Couronne d&#39;un grand p\\xf4le 6 0 3 3 853 ## 120 - Multipolaris\\xe9e des grandes aires urbaines 1 4 0 4 3 ## 211 - Moyen p\\xf4le (5 000 \\xe0 10 000 emplois) 0 3 2 2 3 ## 212 - Couronne d&#39;un moyen p\\xf4le 0 0 0 0 2 ## 221 - Petit p\\xf4le (de 1 500 \\xe0 5 000 emplois) 3 2 1 0 0 ## 222 - Couronne d&#39;un petit p\\xf4le 0 0 0 0 0 ## 300 - Autre commune multipolaris\\xe9e 2 4 0 1 7 ## 400 - Commune isol\\xe9e hors influence des p\\xf4les 3 5 13 4 0 ## REG ## ZAU 24 27 28 32 44 ## 111 - Grand p\\xf4le (plus de 10 000 emplois) 103 140 216 481 322 ## 112 - Couronne d&#39;un grand p\\xf4le 734 1299 1126 1505 1721 ## 120 - Multipolaris\\xe9e des grandes aires urbaines 188 336 488 729 822 ## 211 - Moyen p\\xf4le (5 000 \\xe0 10 000 emplois) 30 31 34 33 54 ## 212 - Couronne d&#39;un moyen p\\xf4le 72 122 104 18 102 ## 221 - Petit p\\xf4le (de 1 500 \\xe0 5 000 emplois) 46 60 78 54 89 ## 222 - Couronne d&#39;un petit p\\xf4le 19 137 29 18 118 ## 300 - Autre commune multipolaris\\xe9e 375 737 762 711 1155 ## 400 - Commune isol\\xe9e hors influence des p\\xf4les 275 969 396 289 815 ## REG ## ZAU 52 53 75 76 84 ## 111 - Grand p\\xf4le (plus de 10 000 emplois) 108 89 333 258 548 ## 112 - Couronne d&#39;un grand p\\xf4le 535 415 1161 1124 1484 ## 120 - Multipolaris\\xe9e des grandes aires urbaines 186 152 254 333 390 ## 211 - Moyen p\\xf4le (5 000 \\xe0 10 000 emplois) 23 47 51 79 43 ## 212 - Couronne d&#39;un moyen p\\xf4le 44 18 81 155 84 ## 221 - Petit p\\xf4le (de 1 500 \\xe0 5 000 emplois) 69 42 163 123 113 ## 222 - Couronne d&#39;un petit p\\xf4le 8 1 81 89 47 ## 300 - Autre commune multipolaris\\xe9e 386 325 1002 877 517 ## 400 - Commune isol\\xe9e hors influence des p\\xf4les 143 181 1379 1527 963 ## REG ## ZAU 93 94 ## 111 - Grand p\\xf4le (plus de 10 000 emplois) 220 8 ## 112 - Couronne d&#39;un grand p\\xf4le 229 99 ## 120 - Multipolaris\\xe9e des grandes aires urbaines 69 3 ## 211 - Moyen p\\xf4le (5 000 \\xe0 10 000 emplois) 20 1 ## 212 - Couronne d&#39;un moyen p\\xf4le 11 2 ## 221 - Petit p\\xf4le (de 1 500 \\xe0 5 000 emplois) 32 13 ## 222 - Couronne d&#39;un petit p\\xf4le 6 29 ## 300 - Autre commune multipolaris\\xe9e 107 53 ## 400 - Commune isol\\xe9e hors influence des p\\xf4les 269 152 7.5 Tableau de proportions La fonction prop.table() prend en entrée un objet table (tableau de contingence avec les effectifs) et calcule les pourcentages (total, ligne, colonne) associés \\(\\rightarrow\\) ?prop.table (prop.table(t) * 100) %&gt;% round(digits = 1) ## REG ## ZAU 1 2 3 4 11 24 ## 111 - Grand p\\xf4le (plus de 10 000 emplois) 0.0 0.0 0.0 0.0 1.1 0.3 ## 112 - Couronne d&#39;un grand p\\xf4le 0.0 0.0 0.0 0.0 2.3 2.0 ## 120 - Multipolaris\\xe9e des grandes aires urbaines 0.0 0.0 0.0 0.0 0.0 0.5 ## 211 - Moyen p\\xf4le (5 000 \\xe0 10 000 emplois) 0.0 0.0 0.0 0.0 0.0 0.1 ## 212 - Couronne d&#39;un moyen p\\xf4le 0.0 0.0 0.0 0.0 0.0 0.2 ## 221 - Petit p\\xf4le (de 1 500 \\xe0 5 000 emplois) 0.0 0.0 0.0 0.0 0.0 0.1 ## 222 - Couronne d&#39;un petit p\\xf4le 0.0 0.0 0.0 0.0 0.0 0.1 ## 300 - Autre commune multipolaris\\xe9e 0.0 0.0 0.0 0.0 0.0 1.0 ## 400 - Commune isol\\xe9e hors influence des p\\xf4les 0.0 0.0 0.0 0.0 0.0 0.7 ## REG ## ZAU 27 28 32 44 52 53 ## 111 - Grand p\\xf4le (plus de 10 000 emplois) 0.4 0.6 1.3 0.9 0.3 0.2 ## 112 - Couronne d&#39;un grand p\\xf4le 3.5 3.1 4.1 4.7 1.5 1.1 ## 120 - Multipolaris\\xe9e des grandes aires urbaines 0.9 1.3 2.0 2.2 0.5 0.4 ## 211 - Moyen p\\xf4le (5 000 \\xe0 10 000 emplois) 0.1 0.1 0.1 0.1 0.1 0.1 ## 212 - Couronne d&#39;un moyen p\\xf4le 0.3 0.3 0.0 0.3 0.1 0.0 ## 221 - Petit p\\xf4le (de 1 500 \\xe0 5 000 emplois) 0.2 0.2 0.1 0.2 0.2 0.1 ## 222 - Couronne d&#39;un petit p\\xf4le 0.4 0.1 0.0 0.3 0.0 0.0 ## 300 - Autre commune multipolaris\\xe9e 2.0 2.1 1.9 3.1 1.1 0.9 ## 400 - Commune isol\\xe9e hors influence des p\\xf4les 2.6 1.1 0.8 2.2 0.4 0.5 ## REG ## ZAU 75 76 84 93 94 ## 111 - Grand p\\xf4le (plus de 10 000 emplois) 0.9 0.7 1.5 0.6 0.0 ## 112 - Couronne d&#39;un grand p\\xf4le 3.2 3.1 4.0 0.6 0.3 ## 120 - Multipolaris\\xe9e des grandes aires urbaines 0.7 0.9 1.1 0.2 0.0 ## 211 - Moyen p\\xf4le (5 000 \\xe0 10 000 emplois) 0.1 0.2 0.1 0.1 0.0 ## 212 - Couronne d&#39;un moyen p\\xf4le 0.2 0.4 0.2 0.0 0.0 ## 221 - Petit p\\xf4le (de 1 500 \\xe0 5 000 emplois) 0.4 0.3 0.3 0.1 0.0 ## 222 - Couronne d&#39;un petit p\\xf4le 0.2 0.2 0.1 0.0 0.1 ## 300 - Autre commune multipolaris\\xe9e 2.7 2.4 1.4 0.3 0.1 ## 400 - Commune isol\\xe9e hors influence des p\\xf4les 3.8 4.2 2.6 0.7 0.4 7.6 Exercice : calcul de statistiques Utilisez la fonction summary() pour obtenir un résumé de l’ensemble des variables de la table df Calculez maintenant les moyenne, médiane, écart-type et variance de la variable de densité de population. Que constatez-vous ? Utilisez le paramètre na.rm = T pour gérer les valeurs manquantes Calulez à présent les quartiles puis déciles de cette variables Calculez la version centrée réduite de la variable de densité. Rappel : on calcule la version centrée réduite d’une variable X en lui appliquant la transformation suivante : \\[ STD_X =\\dfrac{X-\\bar{X}}{\\sigma_X}\\] où \\(\\bar{X}\\) est la moyenne empirique de X et \\(\\sigma_X\\) son écart-type Tableaux croisés : Calculer le nombre de communes par type d’espace à l’aide de la fonction table, et le pourcentage associé Calculer le nombre de communes par région et type d’espace, et les pourcentages associés df &lt;- base %&gt;% select(1:24) %&gt;% mutate(densite = P14_POP / SUPERF, tx_natal = 1000 * NAISD15 / P14_POP, tx_mort = DECESD15 / P14_POP, ZAU2 = as.factor(substr(ZAU, 1, 3))) # Parce que la variable originale est longue summary(df) ## CODGEO LIBGEO REG DEP ## Length:36689 Length:36689 Min. : 1.00 Length:36689 ## Class :character Class :character 1st Qu.:28.00 Class :character ## Mode :character Mode :character Median :44.00 Mode :character ## Mean :52.05 ## 3rd Qu.:76.00 ## Max. :94.00 ## ## ZAU ZE P14_POP P09_POP ## Length:36689 Length:36689 Min. : 0 Min. : 0 ## Class :character Class :character 1st Qu.: 197 1st Qu.: 193 ## Mode :character Mode :character Median : 444 Median : 431 ## Mean : 1838 Mean : 1793 ## 3rd Qu.: 1110 3rd Qu.: 1072 ## Max. :2220445 Max. :2234105 ## NA&#39;s :821 NA&#39;s :821 ## SUPERF NAIS0914 DECE0914 P14_MEN ## Min. : 0.04 Min. : 0.0 Min. : 0.00 Min. : 0.0 ## 1st Qu.: 6.44 1st Qu.: 9.0 1st Qu.: 8.00 1st Qu.: 83.8 ## Median : 10.81 Median : 23.0 Median : 17.00 Median : 183.2 ## Mean : 17.64 Mean : 114.4 Mean : 77.35 Mean : 802.0 ## 3rd Qu.: 18.58 3rd Qu.: 60.0 3rd Qu.: 43.00 3rd Qu.: 454.9 ## Max. :18360.00 Max. :150843.0 Max. :69907.00 Max. :1147990.9 ## NA&#39;s :821 NA&#39;s :821 NA&#39;s :821 NA&#39;s :821 ## NAISD15 DECESD15 P14_LOG P14_RP ## Min. : 0.00 Min. : 0.00 Min. : 0.0 Min. : 0.0 ## 1st Qu.: 1.00 1st Qu.: 1.00 1st Qu.: 115.0 1st Qu.: 83.8 ## Median : 4.00 Median : 3.00 Median : 239.1 Median : 183.2 ## Mean : 21.96 Mean : 16.47 Mean : 970.2 Mean : 802.0 ## 3rd Qu.: 11.00 3rd Qu.: 9.00 3rd Qu.: 565.0 3rd Qu.: 454.9 ## Max. :28267.00 Max. :13997.00 Max. :1362181.9 Max. :1147990.9 ## NA&#39;s :821 NA&#39;s :821 NA&#39;s :821 NA&#39;s :821 ## P14_RSECOCC P14_LOGVAC P14_RP_PROP NBMENFISC13 ## Min. : 0.00 Min. : 0.00 Min. : 0.0 Min. : 32.0 ## 1st Qu.: 7.00 1st Qu.: 8.00 1st Qu.: 68.4 1st Qu.: 102.0 ## Median : 19.00 Median : 18.00 Median : 148.0 Median : 205.0 ## Mean : 91.63 Mean : 76.60 Mean : 462.2 Mean : 809.7 ## 3rd Qu.: 49.29 3rd Qu.: 43.75 3rd Qu.: 349.2 3rd Qu.: 484.0 ## Max. :107061.99 Max. :107129.02 Max. :381934.3 Max. :1038789.0 ## NA&#39;s :821 NA&#39;s :821 NA&#39;s :821 NA&#39;s :3793 ## PIMP13 MED13 TP6013 P14_EMPLT ## Min. :24.46 Min. :10021 Min. : 5.00 Min. : 0.0 ## 1st Qu.:50.57 1st Qu.:18452 1st Qu.: 8.73 1st Qu.: 26.0 ## Median :58.40 Median :19844 Median :11.97 Median : 66.8 ## Mean :58.98 Mean :20250 Mean :13.35 Mean : 733.9 ## 3rd Qu.:67.19 3rd Qu.:21563 3rd Qu.:16.80 3rd Qu.: 229.5 ## Max. :89.38 Max. :46251 Max. :44.84 Max. :1801865.8 ## NA&#39;s :31598 NA&#39;s :3793 NA&#39;s :32531 NA&#39;s :821 ## densite tx_natal tx_mort ZAU2 ## Min. : 0.00 Min. : 0.000 Min. :0.0000 112 :12297 ## 1st Qu.: 18.59 1st Qu.: 5.679 1st Qu.:0.0044 400 : 7383 ## Median : 40.35 Median : 9.264 Median :0.0079 300 : 7021 ## Mean : 160.15 Mean : 9.699 Mean :0.0093 120 : 3962 ## 3rd Qu.: 94.57 3rd Qu.: 12.931 3rd Qu.:0.0124 111 : 3285 ## Max. :27126.14 Max. :111.111 Max. :0.1577 221 : 888 ## NA&#39;s :821 NA&#39;s :827 NA&#39;s :827 (Other): 1853 df %&gt;% pull(densite) %&gt;% mean() df %&gt;% pull(densite) %&gt;% sd() df %&gt;% pull(densite) %&gt;% median() df %&gt;% pull(densite) %&gt;% var() On a des NA car les valeurs manquantes sont absorbantes ! df %&gt;% pull(densite) %&gt;% mean(na.rm = T) df %&gt;% pull(densite) %&gt;% sd(na.rm = T) df %&gt;% pull(densite) %&gt;% median(na.rm = T) df %&gt;% pull(densite) %&gt;% var(na.rm = T) df &lt;- df %&gt;% mutate(std_dens = (densite - mean(densite, na.rm = T)) / sd(densite, na.rm = T)) Avantage des variables centrées réduites : on élimine les effets d’unité (d’ordre de grandeur), et on peut donc comparer les distributions de deux variables qui ont des unités différentes (voir module 3) df %&gt;% pull(densite) %&gt;% quantile(na.rm = T) ## 0% 25% 50% 75% 100% ## 0.00000 18.59047 40.35457 94.57430 27126.14108 seq(0, 1, 0.1) # vérifier la séquence qu&#39;on souhaite ## [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 df %&gt;% pull(densite) %&gt;% quantile(probs = seq(0, 1, 0.1), na.rm = T) ## 0% 10% 20% 30% 40% 50% ## 0.00000 10.03439 15.65357 21.84208 29.76144 40.35457 ## 60% 70% 80% 90% 100% ## 54.82089 77.65199 119.08740 240.40789 27126.14108 t &lt;- table(df$ZAU2) t ## ## 111 112 120 211 212 221 222 300 400 ## 3285 12297 3962 456 815 888 582 7021 7383 100 * prop.table(t) %&gt;% round(digits = 4) ## ## 111 112 120 211 212 221 222 300 400 ## 8.95 33.52 10.80 1.24 2.22 2.42 1.59 19.14 20.12 Deux variables t &lt;- table(df$REG, df$ZAU2) t ## ## 111 112 120 211 212 221 222 300 400 ## 1 17 6 1 0 0 3 0 2 3 ## 2 16 0 4 3 0 2 0 4 5 ## 3 3 3 0 2 0 1 0 0 13 ## 4 10 3 4 2 0 0 0 1 4 ## 11 413 853 3 3 2 0 0 7 0 ## 24 103 734 188 30 72 46 19 375 275 ## 27 140 1299 336 31 122 60 137 737 969 ## 28 216 1126 488 34 104 78 29 762 396 ## 32 481 1505 729 33 18 54 18 711 289 ## 44 322 1721 822 54 102 89 118 1155 815 ## 52 108 535 186 23 44 69 8 386 143 ## 53 89 415 152 47 18 42 1 325 181 ## 75 333 1161 254 51 81 163 81 1002 1379 ## 76 258 1124 333 79 155 123 89 877 1527 ## 84 548 1484 390 43 84 113 47 517 963 ## 93 220 229 69 20 11 32 6 107 269 ## 94 8 99 3 1 2 13 29 53 152 100 * prop.table(t) %&gt;% round(digits = 4) ## ## 111 112 120 211 212 221 222 300 400 ## 1 0.05 0.02 0.00 0.00 0.00 0.01 0.00 0.01 0.01 ## 2 0.04 0.00 0.01 0.01 0.00 0.01 0.00 0.01 0.01 ## 3 0.01 0.01 0.00 0.01 0.00 0.00 0.00 0.00 0.04 ## 4 0.03 0.01 0.01 0.01 0.00 0.00 0.00 0.00 0.01 ## 11 1.13 2.32 0.01 0.01 0.01 0.00 0.00 0.02 0.00 ## 24 0.28 2.00 0.51 0.08 0.20 0.13 0.05 1.02 0.75 ## 27 0.38 3.54 0.92 0.08 0.33 0.16 0.37 2.01 2.64 ## 28 0.59 3.07 1.33 0.09 0.28 0.21 0.08 2.08 1.08 ## 32 1.31 4.10 1.99 0.09 0.05 0.15 0.05 1.94 0.79 ## 44 0.88 4.69 2.24 0.15 0.28 0.24 0.32 3.15 2.22 ## 52 0.29 1.46 0.51 0.06 0.12 0.19 0.02 1.05 0.39 ## 53 0.24 1.13 0.41 0.13 0.05 0.11 0.00 0.89 0.49 ## 75 0.91 3.16 0.69 0.14 0.22 0.44 0.22 2.73 3.76 ## 76 0.70 3.06 0.91 0.22 0.42 0.34 0.24 2.39 4.16 ## 84 1.49 4.04 1.06 0.12 0.23 0.31 0.13 1.41 2.62 ## 93 0.60 0.62 0.19 0.05 0.03 0.09 0.02 0.29 0.73 ## 94 0.02 0.27 0.01 0.00 0.01 0.04 0.08 0.14 0.41 Pour aller plus loin et ajouter des variables de pondération, calculer les profils-ligne ou profils-colonne, rendez-vous au module 3 “Statistiques descriptives” ou demander à un GF (Gentil Formateur). "],["premiers-graphiques.html", "Chapitre 8 Premiers graphiques 8.1 Package ggplot2 8.2 Histogramme 8.3 Nuages de points 8.4 Matrice de nuages 8.5 Bonus : faire un graphique “dynamique” 8.6 Exercices : créer des graphiques", " Chapitre 8 Premiers graphiques 8.1 Package ggplot2 Pour réaliser des graphiques, nous choisissons de nous servir du package ggplot2, qui permet de faire de meilleures réalisations que les fonctions basiques. Il est intégré dans le méta-package tidyverse donc il n’est pas utile de le re-charger dans notre session. Mais si vous devez le faire, le code est le suivant : install.packages(&quot;ggplot2&quot;) library(&quot;ggplot2&quot;) require(dplyr) La fonction ggplot() fonctionne d’une manière particulière. La structure ressemble à ceci : ggplot(TableEnEntree, aes(VariablesATracer)) + geom_FonctionAChoisir() Pour découvrir les nombreuses possibilités de ggplot2, vous pouvez vous référer au Module 5 : « Datavisualisation : produire des graphiques, des cartes et des tableaux » ou consulter les sites suivants : Version anglaise Version française La fonction aes() (pour “aesthetics”), utilisée dans l’instrution ggplot() permet de définir les données à tracer. On y indique les dimensions que l’on veut représenter sur le graphique. On peut représenter jusqu’à 5 dimensions sur un même graphique, mais attention à la lisibilité ! 2 variables quanti : x en fonction de y \\(\\rightarrow\\) 2 dimensions (nuage de points) taille du point \\(\\rightarrow\\) 3e dimension (quanti) couleur des points \\(\\rightarrow\\) 4e dimension (quali) juxtaposer des graphiques en fonction d’une variable quali \\(\\rightarrow\\) 5e dimension ! 8.2 Histogramme Si on désire un histogramme de log_SUPERF, on fera appel à la fonction geom_histogram(). Ce graphique ne présente qu’une seule dimension (la variable quanti dont on veut visualiser la distribution) rm(list = ls()) base &lt;- read.csv(file = &quot;data/Base_synth_territoires.csv&quot;, header = T, sep=&quot;;&quot;, dec=&quot;,&quot;) %&gt;% select(1:24) %&gt;% mutate(log_SUPERF = log (SUPERF), REG = as.factor (REG), densite = P14_POP / SUPERF, tx_natal = 1000 * NAISD15 / P14_POP, tx_mort = DECESD15 / P14_POP) ggplot(base, aes(x = log_SUPERF)) + geom_histogram() 8.3 Nuages de points Selon les graphiques que l’on veut tracer, on peut renseigner plusieurs variables. Dans le cas d’un nuage de points, par exemple, on croise 2 variables quantitatives : ggplot(base, aes(x = P14_EMPLT, y = MED13)) + geom_point(colour = &quot;blue&quot;) ggplot(base, aes(x = log (P14_EMPLT), y = log(MED13))) + geom_point(colour = &quot;blue&quot;) 8.4 Matrice de nuages Pour explorer son jeu de données, on peut réaliser un nuage de points pour plusieurs croisements de variables possibles. Ici, en conservant quelques variables quantitatives, on peut réaliser un ensemble de graphiques. Cette “matrice” de nuages fonctionne avec le package GGally. # install.packages(&quot;GGally&quot;) library(&quot;GGally&quot;) num &lt;- select(base, P14_LOGVAC:PIMP13) %&gt;% sample_n(10000) %&gt;% log() ggpairs(num) ## fonction ggpairs() de GGally 8.5 Bonus : faire un graphique “dynamique” Une fois qu’on a généré un graphique avec ggplot, on peut le passer dans la fonction ggplotly() (package plotly) qui permet de le rendre dynamique. library(plotly) g &lt;- ggplot(data = base, aes(x = REG, fill = REG)) + geom_bar() ggplotly(g) 8.6 Exercices : créer des graphiques À l’aide de l’aide mémoire ggplot2 : Réaliser un histogramme de la population communale Transformer les données avec la fonction log pour y voir plus clair Faire un barplot du nombre de communes par type ZAU Utiliser le paramètre fill de la fonction aes() pour améliorer le graphique Réaliser un graphique (nuage de points) croisant la densité de population et le taux de mortalité Ajouter une dimension supplémentaire avec la couleur des points (paramètre color de aes()) ggplot(data = base, aes(x = P14_POP)) + geom_histogram() Ce n’est pas très informatif, mais on peut faire une transformation log pour y voir plus clair ! ggplot(data = base, aes(x = log(P14_POP))) + geom_histogram() Faites maintenant un barplot (qui n’est pas un histogramme !!!!) du nombre de communes par type ZAU. ggplot(data = base, aes(x = REG)) + geom_bar() On va essayer d’y voir plus clair avec le paramètre fill ggplot(data = base, aes(x = REG, fill = REG)) + geom_bar() ggplot(data = base, aes(x = log(P14_POP), y = log(P14_LOGVAC))) + geom_point() ggplot(data = base, aes(x = densite, y = tx_mort, color = REG)) + geom_point() Là encore il faudrait faire une transformation logarithmique, mais tout ça est abordé dans le module 3 ! Note : avec les fonctions de base, on peut obtenir de nombreux graphiques avec très peu de code, mais moins jolis : plot(iris) Des possibilités infinies à approfondir dans les modules 3 et 5 !! "],["sauvegarder-son-travail.html", "Chapitre 9 Sauvegarder son travail 9.1 Exportation des résultats 9.2 Environnement et .RData", " Chapitre 9 Sauvegarder son travail Après avoir réalisé ces traitements, on peut exporter son travail afin de le finaliser dans un tableur ou un traitement de texte en vue d’une publication ou autre. On peut donc avoir à exporter soit des tableaux qu’on retouchera par la suite, soit des images de ses graphiques qu’on intégrera dans un document. Une dernière possibilité consiste à sauvegarder un ensemble d’objets R dans un seul fichier (RData) afin de retrouver son environnement de travail facilement en rouvrant une session de R. 9.1 Exportation des résultats Exporter une table en csv res &lt;- summary(base) write.table(x = res, file = &#39;outputs/resultat_R.csv&#39;, sep = &#39;;&#39;, row.names = F) # row.names=F pour éviter un décalage entre première ligne et les suivantes write.table(x = base, file = &#39;outputs/base_R.csv&#39;, sep = &#39;;&#39;, row.names = F) Exporter un graphique pour l’intégrer à un document png(&#39;outputs/mongraphe.png&#39;) # Alloue et ouvre le fichier où inscrire le graphe ggplot(base, aes(x = P14_EMPLT, y = MED13)) + geom_point(colour = &quot;blue&quot;) dev.off() # Ferme le fichier \\(\\rightarrow\\) Beaucoup d’autres fonctions : jpeg, pdf, postscript, svg… 9.2 Environnement et .RData Il est possible de sauvegarder des objets R (dataframe, vecteur, etc…) directement sur son ordinateur. Une liste d’objets R est enregistrée sous le format .RData. save(list = ls(), file = &quot;outputs/env_entier.RData&quot;) # sauvegarde de tout l&#39;environnement sur le répertoire choisi rm(list = ls()) # suppression de notre environnement dans R load(&quot;outputs/env_entier.RData&quot;) # chargement de l&#39;environnement stocké sur l&#39;ordinateur save(base, V1, file = &quot;outputs/petit_env.RData&quot;) # sauvegarde des éléments base et V1 rm(list = ls()) # suppression de notre environnement load(outputs/&quot;petit_env.RData&quot;) Avantages - Un seul fichier peut contenir des dataframes, des graphiques, des fonctions, etc. - La lecture est très rapide \\(\\Rightarrow\\) utile pour les gros volumes de données "],["aller-plus-loin-avec-les-objets-crochets-et-la-programmation-fonctionnelle.html", "Chapitre 10 Aller plus loin avec les objets, crochets et la programmation fonctionnelle 10.1 Les objets dans R 10.2 Sélectionner des lignes et des colonnes 10.3 Créer une nouvelle fonction en R 10.4 Les boucles conditionnelles 10.5 Les boucles 10.6 Exercices", " Chapitre 10 Aller plus loin avec les objets, crochets et la programmation fonctionnelle Ce qui a été présenté dans ce module repose sur les fonctions du package tidyverse. Cette approche tend à se généraliser depuis quelques années, mais quand on cherche la réponse à un problème sur Internet, on trouve d’autres façons de programmer en R, qui font appel aux fonctions du package base et non du tidyverse \\(\\Rightarrow\\) Cette partie donne quelques clés de compréhension. 10.1 Les objets dans R Rappel : en informatique, un objet est défini par : ses attributs et ses méthodes (fonctions). Dans l’exemple du jeu d’échec, chaque pièce peut être vue comme un objet : sa position sur le plateau constitue ses attributs sa façon de se déplacer peut être vue comme une fonction qui ne s’applique qu’à ce type de pièce, donc une méthode R est un langage orienté objet ; ces objets permettent de structurer les données selon leurs caractéristiques \\(\\Rightarrow\\) on retrouve les données dans les attributs. Les méthodes sont en général transparentes pour l’utilisateur (cf. utilisation des fonctions summary, plot…). Les objets les plus courants sont les suivants : Vecteurs : suite unidimensionnelle de valeurs ayant le même type. Facteurs : vecteur qui prend un nombre limité de modalités (exemple : sexe). Il est défini par les niveaux (levels) et les libellés associés (labels). Matrice et arrays : suites multidimensionnelles de valeurs (matrices=dimension 2 ; array=dimension n). Liste : ensemble d’objets différents. On peut stocker un vecteur alphanumérique + une matrice numérique dans une liste. Tableaux (data.frame) : Objet qui ressemble le plus aux tables Excel, SAS ou SPSS… : description d’individus statistiques (observations, en ligne) par des caractéristiques (variables, en colonnes). Fonctions : Objets particuliers qui donnent un résultat à partir de paramètres en entrée. Autres objets : Il existe un très grand nombre d’objets ad hoc dans R. Par exemple ts (time serie) pour les séries temporelles, lm (linear model) qui contient tous les résultats d’une régression linéraire… des graphiques On peut même en définir de nouveaux soi-même ! La fonction c permet de lister simplement les valeurs que l’on veut stocker dans l’objet ; la fonction seq génére une suite incrémentée. Il existe aussi la fonction rep qui réplique n fois la même valeur. 10.1.1 Créer des vecteurs v1 &lt;- seq(1 : 10) v2 &lt;- c (&quot;lundi&quot;, &quot;mardi&quot;, &quot;mercredi&quot;, &quot;jeudi&quot;, &quot;vendredi&quot;, &quot;samedi&quot;, &quot;dimanche&quot;) 10.1.2 Créer une matrice m &lt;- matrix (v1, nrow = 10, ncol = 7) l &lt;- list (v1, v2, m) 10.1.3 Visualiser ces objets et leurs attributs Quelques fonctions simples : print, View, names, colnames, rownames, typeof, str, dim v1 ## [1] 1 2 3 4 5 6 7 8 9 10 print (v2) ## [1] &quot;lundi&quot; &quot;mardi&quot; &quot;mercredi&quot; &quot;jeudi&quot; &quot;vendredi&quot; &quot;samedi&quot; &quot;dimanche&quot; typeof (v2) # Permet de visualiser le type ## [1] &quot;character&quot; dim (m) ## [1] 10 7 str (l) # Permet de visualiser les attributs ## List of 3 ## $ : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## $ : chr [1:7] &quot;lundi&quot; &quot;mardi&quot; &quot;mercredi&quot; &quot;jeudi&quot; ... ## $ : int [1:10, 1:7] 1 2 3 4 5 6 7 8 9 10 ... 10.2 Sélectionner des lignes et des colonnes Il est aussi possible d’accéder aux éléments d’un dataframe à partir du numéro de ligne et de colonne, grâce aux crochets : base[1,3] \\(\\rightarrow\\) valeur de la première ligne et de la troisième colonne base[2,] \\(\\rightarrow\\) toutes les variables pour la 2e observation base[,4] \\(\\rightarrow\\) toutes les observations de la quatrième colonne base[,’V6’] \\(\\rightarrow\\) toutes les observations de la variable V6 \\(\\Rightarrow\\) Utile pour sélectionner une partie d’une table : base[1:4, c(3, 6)] 10.3 Créer une nouvelle fonction en R La fonction est un objet comme les autres, qu’on crée avec l’opérateur d’affectation. Elle est définie par des paramètres et elle se termine par la fonction return(). On reprend l’exemple du calcul de l’IMC calcul_IMC &lt;- function (poids, taille) { ## La taille est exprimée en mètres imc &lt;- poids / taille ^ 2 return (imc) } calcul_IMC (poids = 80, taille = 1.89) ## [1] 22.39579 calcul_IMC (poids = 60, taille = 1.55) ## [1] 24.97399 10.4 Les boucles conditionnelles Les commandes if et else sont bien entendues utilisables. Le “then” n’existe pas : il est implicite après les accolades. diag_IMC &lt;- function(poids,taille) { imc &lt;- poids / taille ^ 2 if (imc &lt; 18.5) {diag &lt;- &quot;maigre&quot;} else if (imc &lt; 25) {diag &lt;- &quot;normal&quot;} else {diag &lt;- &quot;surpoids&quot;} return (diag) } diag_IMC (poids=60,taille=1.89) ## [1] &quot;maigre&quot; diag_IMC (poids=80,taille=1.89) ## [1] &quot;normal&quot; diag_IMC (poids=80,taille=1.55) ## [1] &quot;surpoids&quot; 10.5 Les boucles On peut utiliser les boucles classiques : repeat, while, for : for (pp in seq(from = 50, to = 100, by = 5)) { print(paste (&quot;Taille = 1,70m, poids =&quot;, pp, &quot;Diagnotic :&quot;, diag_IMC (poids = pp, taille = 1.70))) } ## [1] &quot;Taille = 1,70m, poids = 50 Diagnotic : maigre&quot; ## [1] &quot;Taille = 1,70m, poids = 55 Diagnotic : normal&quot; ## [1] &quot;Taille = 1,70m, poids = 60 Diagnotic : normal&quot; ## [1] &quot;Taille = 1,70m, poids = 65 Diagnotic : normal&quot; ## [1] &quot;Taille = 1,70m, poids = 70 Diagnotic : normal&quot; ## [1] &quot;Taille = 1,70m, poids = 75 Diagnotic : surpoids&quot; ## [1] &quot;Taille = 1,70m, poids = 80 Diagnotic : surpoids&quot; ## [1] &quot;Taille = 1,70m, poids = 85 Diagnotic : surpoids&quot; ## [1] &quot;Taille = 1,70m, poids = 90 Diagnotic : surpoids&quot; ## [1] &quot;Taille = 1,70m, poids = 95 Diagnotic : surpoids&quot; ## [1] &quot;Taille = 1,70m, poids = 100 Diagnotic : surpoids&quot; 10.6 Exercices 10.6.1 Vecteurs simples Créer trois vecteurs : un numérique, un caractère et un facteur. Vous pouvez vous aider des fonctions c(), rnorm() (génération d’une variable aléatoire selon une loi normale), seq() ou rep() Regrouper ces variables dans un dataframe, puis dans une liste. Dans les deux configurations, afficher la variable contenant les tailles (vtaille). Pour la liste, utiliser les [] et [[]]. rm (list = ls ()) x &lt;- c (1, 160, 2, 9, 60) x1 &lt;- c(&quot;Je&quot;, &quot;programme&quot;, &quot;en&quot;, &quot;R&quot;) # Guillemets pour indiquer que c&#39;est une variable textuelle y &lt;- seq (from = 1, to = 10, by = 1) z &lt;- rep (x = 1, times = 100) x &lt;- rnorm (n = 30) # création de vecteurs avec la fonction c() = combine v1 &lt;- c( 3, 4, 12, 15, 32, 6, 1, 2, 3, 9) # avec la fonction seq() = sequence, généralisation de la syntaxe ci-dessus v2 &lt;- seq(from = 1 , to = 15 , by = 1.5) # syntaxe équivalente mais préférable car plus lisible : v2b &lt;- seq (from=1, to=15, by=1.5) v3 &lt;- 1:10 # avec la fonction rep() = répétition v4 &lt;- rep (x = 4, times = 10) # ces commandes peuvent être combinées. Pratique pour créer des variables &quot;facteur&quot; v5 &lt;- rep (x = c(3, 4, 1.2, 8, 9), times = 2) v6 &lt;- rep (x = 1:5, times = 2) # vecteurs de type texte ou factor vtaille &lt;- rep (x = c (&quot;S&quot;, &quot;L&quot;), times = 5) vtaille &lt;- factor (vtaille) # concaténation de vecteurs gtaille &lt;- paste(&quot;X&quot;, vtaille, sep = &quot;&quot;) gtaille &lt;- factor (gtaille) toutes_taille &lt;- c (as.character (vtaille), as.character (gtaille)) toutes_taille &lt;- as.factor (toutes_taille) levels (toutes_taille) ## [1] &quot;L&quot; &quot;S&quot; &quot;XL&quot; &quot;XS&quot; 10.6.2 Dataframes et listes dataf &lt;- data.frame (vtaille, v1, v2, v3, v4, v5, v6) liste &lt;- list (vtaille, v1, v2, v3, v4, v5, v6) names(liste) &lt;- c (&quot;vtaille&quot;, &quot;v1&quot;, &quot;v2&quot;, &quot;v3&quot;, &quot;v4&quot;, &quot;v5&quot;, &quot;v6&quot;) dataf$vtaille ## [1] S L S L S L S L S L ## Levels: L S liste$vtaille ## [1] S L S L S L S L S L ## Levels: L S rm (dataf, vtaille, v1, v2, v2b, v3, v4, v5, v6) 10.6.3 Pour aller plus loin : matrices et arrays Les matrices et les arrays permettent des calculs rapides et efficaces, et peuvent être très pratiques et optimisent le stockage des données. Ils demandent cependant plus de réflexion en amont quant à leur utilisation, mais . On accède aux éléments avec les []. Créer une matrice à 10 lignes et 10 colonnes remplie avec un tirage aléatoire selon une loi normale centrée réduit. Créer un hypercube avec la fonction array() avec 10 lignes, 5 colonnes et de profondeur 3, toujours avec un tirage aléatoire selon une loi normale Un hypercube de trois dimensions peut être représenté comme suit : mat &lt;- matrix(rnorm(50), ncol = 5, nrow = 10) arr &lt;- array(rnorm(150),dim = c(10,5,3)) mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1.4704016 0.06611292 -0.19267472 0.61818224 0.727807630 ## [2,] 1.9697550 -0.47718641 0.05483175 1.83551428 -1.009176365 ## [3,] -0.9866953 3.30874759 -0.03464381 -1.35924002 -0.007525397 ## [4,] 0.0112638 -1.01056572 -1.31953062 1.35630954 1.114239145 ## [5,] -0.2117940 0.68820823 -0.01309241 -0.66526172 -0.864822420 ## [6,] 0.9205981 -1.16774215 -0.15972542 0.08688058 -1.482296253 ## [7,] 0.2494718 0.37381266 1.15785243 -0.09617666 -0.689659184 ## [8,] -0.5775302 -0.41974558 1.27201907 0.32358282 1.079620902 ## [9,] 1.6002739 -0.44591294 1.27385291 0.56177719 1.069128832 ## [10,] 1.5989952 -0.32070510 -0.22388832 -1.98339773 -0.403774668 arr ## , , 1 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] -1.29237012 1.8268202 0.51921782 0.54783980 0.01859878 ## [2,] 1.35717170 0.3288017 0.08588212 -0.65810835 -0.82626037 ## [3,] 0.34193629 -0.5983830 0.36737097 -1.71089492 -0.93914369 ## [4,] 0.38546982 -0.6343357 0.62566510 0.09849613 1.55690669 ## [5,] 0.06472883 1.2624667 -0.03150256 -1.07587885 -0.66854643 ## [6,] 0.17072820 1.3608416 -0.93956912 1.75826589 0.53013620 ## [7,] -0.66368181 0.1782711 -1.39680468 0.49963406 1.29883870 ## [8,] -0.45787142 -0.4660769 2.35366282 0.41307903 -1.51890112 ## [9,] -0.32154905 0.4701995 0.20960049 1.29718169 -2.50758426 ## [10,] 0.36937498 -1.6975357 0.77251094 -0.11051644 0.47901683 ## ## , , 2 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0.48496562 -0.03492875 -0.19766619 1.329512206 -0.8540331 ## [2,] -0.08594712 0.49509673 -0.66958621 -0.089738819 0.9873441 ## [3,] 0.60487258 -0.38925583 1.04927170 0.667562456 -0.9524362 ## [4,] 1.24080360 -0.39702819 -2.33995414 -0.643812697 -0.2999225 ## [5,] -0.72690203 0.42657905 -0.09519256 0.004193966 0.9266832 ## [6,] -0.43622144 -0.62760853 0.88276132 2.010730564 -0.2300346 ## [7,] 0.52535419 1.80211439 0.21996904 0.694577842 -0.1359607 ## [8,] 0.96159504 0.59820047 -0.47775418 1.005905983 1.2236044 ## [9,] 0.19846622 0.01641627 -1.77920639 -0.386956433 1.2137106 ## [10,] 0.56208501 -0.86268003 -0.13502280 -0.935394496 2.3252414 ## ## , , 3 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0.81555796 1.5682902 -1.95519301 -0.57486776 -1.64588421 ## [2,] -1.10177905 0.6187618 -0.50034823 -0.24792243 -0.36542480 ## [3,] -1.06101913 1.0098758 -0.76298107 1.88727316 -0.47433071 ## [4,] 0.13651356 0.4702280 -1.16155663 -0.04538542 -0.03325519 ## [5,] -0.25104312 0.7352819 1.02850376 0.43062558 0.45525685 ## [6,] 0.28356013 1.5453576 -1.67628686 -0.26338441 0.68740085 ## [7,] -0.08778857 0.1331438 -1.10859178 0.24511220 -1.90620442 ## [8,] 0.59377365 0.3836979 0.07904839 -0.29063755 1.42817750 ## [9,] 0.10264078 0.2234653 -0.88177122 -0.09007841 0.10226317 ## [10,] 1.24339559 -0.2371316 -1.34826303 2.78796898 -2.20115828 Pourquoi s’embêter avec ça ? Parce qu’on peut appliquer des fonctions facilement sur les lignes, colonnes et autres dimensions grâce à la fonction apply(). Exemple : résultats de validations croisées par bloc, simulations de loi selon différents paramètres. Et on calcule facilement des statistiques “marginales.” Par, exemple, sur une matrice, on peut calculer des statistiques par lignes : apply(mat, MARGIN = 1, FUN=mean) ## [1] 0.53796594 0.47474765 0.18412861 0.03034323 -0.21335247 -0.36045703 ## [7] 0.19906020 0.33558940 0.81182397 -0.26655412 Ou par colonnes : apply(mat, MARGIN = 2, FUN=mean) ## [1] 0.60447397 0.05950235 0.18150009 0.06781705 -0.04664578 Sur notre hypercube de type array, on peut aussi calculer des stats sur ses différentes dimensions : apply (arr, MARGIN = 3, FUN=mean) ## [1] 0.06066400 0.17348748 -0.02554225 apply (arr, MARGIN = c(2,3), FUN = mean) ## [,1] [,2] [,3] ## [1,] -0.004606257 0.3329072 0.06738118 ## [2,] 0.203106949 0.1026906 0.64509707 ## [3,] 0.256603390 -0.3542380 -0.82874397 ## [4,] 0.105909804 0.3656581 0.38387039 ## [5,] -0.257693866 0.4204197 -0.39531592 Le coin du capitaine [ ] Le crochet, c’est comme le capitaine du même nom : personne ne l’aime, mais sans lui, pas de Peter Pan, pas de Neverland ! Moralité, on s’en sert beacoup pour pimenter les codes ! On peut utiliser les crochets pour accéder aux éléments des matrices/arrays et dataframe/listes. Matrices et arrays mat [1,1] ## [1] 1.470402 mat [1,] ## [1] 1.47040162 0.06611292 -0.19267472 0.61818224 0.72780763 mat [,1] ## [1] 1.4704016 1.9697550 -0.9866953 0.0112638 -0.2117940 0.9205981 ## [7] 0.2494718 -0.5775302 1.6002739 1.5989952 arr [1,1,1] ## [1] -1.29237 arr [1,,] ## [,1] [,2] [,3] ## [1,] -1.29237012 0.48496562 0.8155580 ## [2,] 1.82682018 -0.03492875 1.5682902 ## [3,] 0.51921782 -0.19766619 -1.9551930 ## [4,] 0.54783980 1.32951221 -0.5748678 ## [5,] 0.01859878 -0.85403311 -1.6458842 arr [,,1] ## [,1] [,2] [,3] [,4] [,5] ## [1,] -1.29237012 1.8268202 0.51921782 0.54783980 0.01859878 ## [2,] 1.35717170 0.3288017 0.08588212 -0.65810835 -0.82626037 ## [3,] 0.34193629 -0.5983830 0.36737097 -1.71089492 -0.93914369 ## [4,] 0.38546982 -0.6343357 0.62566510 0.09849613 1.55690669 ## [5,] 0.06472883 1.2624667 -0.03150256 -1.07587885 -0.66854643 ## [6,] 0.17072820 1.3608416 -0.93956912 1.75826589 0.53013620 ## [7,] -0.66368181 0.1782711 -1.39680468 0.49963406 1.29883870 ## [8,] -0.45787142 -0.4660769 2.35366282 0.41307903 -1.51890112 ## [9,] -0.32154905 0.4701995 0.20960049 1.29718169 -2.50758426 ## [10,] 0.36937498 -1.6975357 0.77251094 -0.11051644 0.47901683 dataframes et listes : Pour les dataframes, le fonctionnement est le même que pour les matrices. Pour les listes, une paire de crochet renvoie un résultat sous forme de liste, un double crochet renvoie le résultat sous sa forme naturelle (ex : vecteur ou matrice). str (liste [1]) ## List of 1 ## $ vtaille: Factor w/ 2 levels &quot;L&quot;,&quot;S&quot;: 2 1 2 1 2 1 2 1 2 1 str (liste [[1]]) ## Factor w/ 2 levels &quot;L&quot;,&quot;S&quot;: 2 1 2 1 2 1 2 1 2 1 liste[&quot;v6&quot;] ## $v6 ## [1] 1 2 3 4 5 1 2 3 4 5 liste[c(&quot;v6&quot;, &quot;v5&quot;)] ## $v6 ## [1] 1 2 3 4 5 1 2 3 4 5 ## ## $v5 ## [1] 3.0 4.0 1.2 8.0 9.0 3.0 4.0 1.2 8.0 9.0 Dans la syntaxe tidyverse, on ne met pas (obligatoirement) de guillemets pour les noms de variable, alors qu’on le fait pour la version [ ]. 10.6.4 Inspection d’un objet : la régression La régression linéaire consiste à exprimer une variable Y en fonction d’une variable X dans une fonction linéaire. C’est à dire qu’on cherche a et b tels que : \\[ Y = a \\cdot X + b + \\epsilon\\] où \\(\\epsilon\\) est le résidu de la régression. On utilise dans cet exemple la table des iris de Fisher, existant dans R base qu’il suffit d’appeler avec data(iris) (il existe d’autres dataframe inclus dans les packages et qui sont utilisés en exemple dans l’aide). data (&quot;iris&quot;) str (iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... Faire la régression de la Sepal.Length sur Petal.length à l’aide de la fonction lm() lm (data = iris, formula = Sepal.Length ~ Petal.Length) ## ## Call: ## lm(formula = Sepal.Length ~ Petal.Length, data = iris) ## ## Coefficients: ## (Intercept) Petal.Length ## 4.3066 0.4089 On a les paramètres a et b mais on aimerait en savoir plus… Au moins la qualité d’ajustement (le \\(R^2\\) par exemple), et un graphique des résidus pour détecter une éventuelle structure. Pour cela, stocker le résultat dans un nouvel objet, et explorez-le avec les fonctions str(), summary() et plot() reg &lt;- lm(data = iris, formula = Sepal.Length ~ Petal.Length) str (reg) ## List of 12 ## $ coefficients : Named num [1:2] 4.307 0.409 ## ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;(Intercept)&quot; &quot;Petal.Length&quot; ## $ residuals : Named num [1:150] 0.2209 0.0209 -0.1382 -0.32 0.1209 ... ## ..- attr(*, &quot;names&quot;)= chr [1:150] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ effects : Named num [1:150] -71.566 8.812 -0.155 -0.337 0.104 ... ## ..- attr(*, &quot;names&quot;)= chr [1:150] &quot;(Intercept)&quot; &quot;Petal.Length&quot; &quot;&quot; &quot;&quot; ... ## $ rank : int 2 ## $ fitted.values: Named num [1:150] 4.88 4.88 4.84 4.92 4.88 ... ## ..- attr(*, &quot;names&quot;)= chr [1:150] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ assign : int [1:2] 0 1 ## $ qr :List of 5 ## ..$ qr : num [1:150, 1:2] -12.2474 0.0816 0.0816 0.0816 0.0816 ... ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : chr [1:150] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## .. .. ..$ : chr [1:2] &quot;(Intercept)&quot; &quot;Petal.Length&quot; ## .. ..- attr(*, &quot;assign&quot;)= int [1:2] 0 1 ## ..$ qraux: num [1:2] 1.08 1.1 ## ..$ pivot: int [1:2] 1 2 ## ..$ tol : num 1e-07 ## ..$ rank : int 2 ## ..- attr(*, &quot;class&quot;)= chr &quot;qr&quot; ## $ df.residual : int 148 ## $ xlevels : Named list() ## $ call : language lm(formula = Sepal.Length ~ Petal.Length, data = iris) ## $ terms :Classes &#39;terms&#39;, &#39;formula&#39; language Sepal.Length ~ Petal.Length ## .. ..- attr(*, &quot;variables&quot;)= language list(Sepal.Length, Petal.Length) ## .. ..- attr(*, &quot;factors&quot;)= int [1:2, 1] 0 1 ## .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. ..$ : chr [1:2] &quot;Sepal.Length&quot; &quot;Petal.Length&quot; ## .. .. .. ..$ : chr &quot;Petal.Length&quot; ## .. ..- attr(*, &quot;term.labels&quot;)= chr &quot;Petal.Length&quot; ## .. ..- attr(*, &quot;order&quot;)= int 1 ## .. ..- attr(*, &quot;intercept&quot;)= int 1 ## .. ..- attr(*, &quot;response&quot;)= int 1 ## .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; ## .. ..- attr(*, &quot;predvars&quot;)= language list(Sepal.Length, Petal.Length) ## .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:2] &quot;numeric&quot; &quot;numeric&quot; ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Sepal.Length&quot; &quot;Petal.Length&quot; ## $ model :&#39;data.frame&#39;: 150 obs. of 2 variables: ## ..$ Sepal.Length: num [1:150] 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## ..$ Petal.Length: num [1:150] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## ..- attr(*, &quot;terms&quot;)=Classes &#39;terms&#39;, &#39;formula&#39; language Sepal.Length ~ Petal.Length ## .. .. ..- attr(*, &quot;variables&quot;)= language list(Sepal.Length, Petal.Length) ## .. .. ..- attr(*, &quot;factors&quot;)= int [1:2, 1] 0 1 ## .. .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. .. ..$ : chr [1:2] &quot;Sepal.Length&quot; &quot;Petal.Length&quot; ## .. .. .. .. ..$ : chr &quot;Petal.Length&quot; ## .. .. ..- attr(*, &quot;term.labels&quot;)= chr &quot;Petal.Length&quot; ## .. .. ..- attr(*, &quot;order&quot;)= int 1 ## .. .. ..- attr(*, &quot;intercept&quot;)= int 1 ## .. .. ..- attr(*, &quot;response&quot;)= int 1 ## .. .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; ## .. .. ..- attr(*, &quot;predvars&quot;)= language list(Sepal.Length, Petal.Length) ## .. .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:2] &quot;numeric&quot; &quot;numeric&quot; ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Sepal.Length&quot; &quot;Petal.Length&quot; ## - attr(*, &quot;class&quot;)= chr &quot;lm&quot; summary (reg) ## ## Call: ## lm(formula = Sepal.Length ~ Petal.Length, data = iris) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.24675 -0.29657 -0.01515 0.27676 1.00269 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 4.30660 0.07839 54.94 &lt;2e-16 *** ## Petal.Length 0.40892 0.01889 21.65 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.4071 on 148 degrees of freedom ## Multiple R-squared: 0.76, Adjusted R-squared: 0.7583 ## F-statistic: 468.6 on 1 and 148 DF, p-value: &lt; 2.2e-16 plot (reg) Les méthodes summary, print et plot sont implémentées pour tous les objets en R, et on peut les utiliser pour avoir un premier aperçu de ce que l’on obtient avec la fonction. "],["exercices-1.html", "Chapitre 11 Exercices 11.1 Création et manipulation d’objets dans R 11.2 Premier jeu de données, premières statistiques 11.3 Mes premiers graphiques et statistiques", " Chapitre 11 Exercices 11.1 Création et manipulation d’objets dans R Ces exercices de mise en oeuvre des notions vues pendant la présentation se déroulent en deux parties : Manipulation des objets R sans recours à une base de données Importation d’une base de données à partir d’un fichier CSV et premières manipulations Premiers graphiques et statistiques. Par défaut, les résultats attendus sont affichés, et, si vous séchez, vous pouvez afficher le code les ayant généré en cliquant sur “code.” A tout moment, vous pouvez donc copier / coller le code dans l’éditeur de script ou la console pour exécuter les commandes présentées. Ces exercices nécessitent les packages de base et le package tidyverse, ce dernier regroupe un ensemble de fonctions à la syntaxe très simple. library(dplyr) library(ggplot2) 11.1.1 Génération de vecteurs Créez trois vecteurs : un numérique, un caractère et un facteur. Vous pouvez vous aider des fonctions c(), rnorm() (génération d’une variable aléatoire selon une loi normale), seq() ou rep() rm(list=ls()) x &lt;- c(1,160,2,9,60) x1 &lt;- c(&quot;Je&quot;,&quot;programme&quot;,&quot;en&quot;,&quot;R&quot;) # Guillemets pour indiquer que c&#39;est une variable textuelle y &lt;- seq(1,10) z &lt;- rep(1,100) x &lt;- rnorm(n = 30) # création de vecteurs avec la fonction c() = combine v1 &lt;- c(3,4,12,15,32,6,1,2,3,9) # avec la fonction seq() = sequence, g?n?ralisation de la syntaxe ci-dessus v2 &lt;- seq(1 , 15 , 1.5) # syntaxe équivalente mais préférable car plus lisible : v2b&lt;-seq(from=1 , to=15 , by=1.5) v3&lt;-1:10 # avec la fonction rep() = répétition v4&lt;-rep(4,10) # ces commandes peuvent être combinées. Pratique pour créer des variables &quot;facteur&quot; v5 &lt;- rep(c(3,4,1.2,8,9),2) v6 &lt;- rep(1:5,2) # vecteurs de type texte ou factor vtaille &lt;- rep(c(&quot;S&quot;,&quot;L&quot;),5) vtaille &lt;- factor(vtaille) # concaténation de vecteurs gtaille &lt;- paste(&quot;X&quot;,vtaille,sep=&quot;&quot;) gtaille &lt;- factor(gtaille) toutes_taille &lt;- c(as.character(vtaille),as.character(gtaille)) toutes_taille &lt;- as.factor(toutes_taille) levels(toutes_taille) ## [1] &quot;L&quot; &quot;S&quot; &quot;XL&quot; &quot;XS&quot; Regroupez ces variables dans un dataframe, puis dans une liste. Dans les deux configurations, affichez la variable contenant les tailles (vtaille). Pour la liste, vous pouvez utiliser les [] et [[]]. 11.1.2 Génération d’autres objets 11.1.2.1 Dataframes et listes dataf &lt;- data.frame(vtaille,v1,v2,v3,v4,v5,v6) liste &lt;- list(vtaille,v1,v2,v3,v4,v5,v6) names(liste) &lt;- c(&quot;vtaille&quot;,&quot;v1&quot;,&quot;v2&quot;,&quot;v3&quot;,&quot;v4&quot;,&quot;v5&quot;,&quot;v6&quot;) dataf$vtaille ## [1] S L S L S L S L S L ## Levels: L S liste$vtaille ## [1] S L S L S L S L S L ## Levels: L S rm(dataf,vtaille,v1,v2,v2b,v3,v4,v5,v6) 11.1.2.2 Pour aller plus loin : matrices et arrays Les matrices et les arrays permettent des calculs rapides et efficaces, peuvent être très pratiques et optimisent le stockage des données. Ils demandent cependant plus de réflexion en amont quant à leur utilisation. On accède aux éléments avec les []. Créer une matrice (10 lignes et 10 colonnes) remplie avec un tirage aléatoire selon une loi normale centrée réduit. Créer un hypercube avec la fonction array() avec 10 lignes, colonnes et de profondeur 3, toujours avec un tirage aléatoire selon une loi normale mat &lt;- matrix(rnorm(100),ncol = 10, nrow = 10) arr &lt;- array(rnorm(300),dim = c(10,10,3)) mat ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 0.32066363 1.93426168 -1.02097119 1.51963761 -0.60480832 -1.02661471 ## [2,] 0.52310197 0.07612066 0.28254217 0.04312867 0.85520977 -0.91463381 ## [3,] 1.95463151 -0.21470516 -0.04714768 0.17944073 0.37582035 -0.94504215 ## [4,] 1.20640703 0.35083076 -0.62491579 0.86984864 1.06874373 -0.11593327 ## [5,] -1.08773672 -1.41277229 0.44083946 -0.79417122 0.12667366 0.39314683 ## [6,] -1.37512318 -1.28596046 1.02370869 -1.77286995 -0.85432899 -0.37934853 ## [7,] -1.84662797 1.40373502 -0.12349211 0.42381842 1.93221061 0.60734544 ## [8,] -1.06825212 -1.01575511 0.08970867 0.47938051 -0.92886259 -1.08572967 ## [9,] -0.16996945 -0.06697527 1.35414799 2.21888050 1.16183103 -0.01335952 ## [10,] -0.04904652 1.59064549 -1.39782365 0.14009077 -0.09456023 -0.63745904 ## [,7] [,8] [,9] [,10] ## [1,] -2.3506341 0.94320690 0.1855897 -0.81429760 ## [2,] 1.4406818 -1.15359301 -1.4915441 0.27125613 ## [3,] 0.6105551 -0.58558776 0.7681287 0.41535171 ## [4,] -1.1655950 0.34497129 0.1597406 -0.80149489 ## [5,] -0.2385934 0.98740927 0.1379708 0.49758686 ## [6,] -2.2626926 0.07837575 0.2153006 -2.27947396 ## [7,] -2.2073226 0.61172147 1.5831852 0.19588137 ## [8,] -0.9549673 -2.45858043 0.1625430 0.03093786 ## [9,] -0.3623859 0.69533718 -1.7574470 -0.78610137 ## [10,] -0.6166251 -2.00729097 -0.1342807 0.15692668 arr ## , , 1 ## ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 2.1351655 0.13380731 1.15962369 0.9365680 -1.1207742 0.45445540 ## [2,] -2.1661246 -1.44348480 -0.43543464 -1.4348564 -0.8925491 -1.20521878 ## [3,] -0.7449696 -0.03254835 0.64725054 -0.5766552 0.7865341 -1.08271653 ## [4,] -0.8158185 -0.31306207 -1.75313718 1.3809233 -1.1213476 -0.78642393 ## [5,] -0.1481436 0.32852426 1.40409854 -1.1452945 -1.1525760 0.40795577 ## [6,] -0.6323061 0.75680619 -0.34263728 -2.1331954 -0.2997279 0.76150667 ## [7,] 1.4462024 -0.45378663 0.54896418 0.5836715 -0.3369027 0.46020660 ## [8,] -0.8825424 -0.56472615 1.05199269 -0.9600739 -0.7677224 -1.56848590 ## [9,] 0.4013431 0.09958858 0.03105386 0.1758877 -0.6666842 0.48881393 ## [10,] -0.3286944 0.49084039 0.47350858 -1.2694805 -1.9458723 0.06626985 ## [,7] [,8] [,9] [,10] ## [1,] -0.8845087 0.57946986 0.1582721 -0.68049285 ## [2,] 1.2920075 1.98136714 0.8233524 0.09804576 ## [3,] 1.2791096 0.30123281 0.2328240 -0.48961287 ## [4,] 0.3604145 -0.09609509 -0.6905764 0.78758126 ## [5,] -0.2100855 0.44322758 -0.7703918 -0.17091149 ## [6,] 0.1988000 -0.42518433 -0.8025606 0.43134272 ## [7,] -1.0756127 0.20038058 0.4257759 0.99396373 ## [8,] 1.1161335 -1.04467844 0.1076472 -1.03620745 ## [9,] -0.6641683 -0.72420753 0.3178149 0.27491803 ## [10,] -0.4413926 -1.50464985 -0.8443428 0.67559733 ## ## , , 2 ## ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 0.12294568 -0.7896653 -0.4220682 -0.56001176 -1.38059478 0.13902909 ## [2,] 0.72414143 -0.7831801 -0.9655484 -1.54769338 0.05098110 1.46042383 ## [3,] 0.06902323 -1.2582677 0.4019953 0.03654781 0.14710427 0.05961747 ## [4,] 1.61700054 0.4879828 0.5857950 -1.37928101 0.38021117 1.64788637 ## [5,] 0.80635332 0.4662656 0.5357998 -0.79924750 -0.07533075 -0.15685835 ## [6,] -0.86708602 -1.0222193 0.2976778 -1.33096366 1.98825596 -0.05835426 ## [7,] -1.13819427 1.6156422 -0.0907620 1.57744528 -0.27716833 1.00645797 ## [8,] -0.79216409 -1.3110033 1.4778518 0.32444033 -0.03462010 0.35390944 ## [9,] -0.39694619 1.6846414 1.0986736 1.14583994 0.62404687 -0.21139375 ## [10,] 1.44750721 0.4704761 0.9062133 2.12570382 1.44286376 1.27470459 ## [,7] [,8] [,9] [,10] ## [1,] 0.700915880 0.75282620 -1.04911033 1.04989492 ## [2,] -0.385130563 -0.93525602 -0.39846585 -0.42086403 ## [3,] -1.604834791 0.77325234 -0.04579083 -1.94667425 ## [4,] 1.945831256 0.55213687 -0.62147864 1.12169808 ## [5,] 0.302982803 0.78285000 0.20440768 -1.16705839 ## [6,] -0.512482634 -0.04227483 -1.53271810 -0.22581994 ## [7,] -0.007964719 -1.20202298 -0.65162632 1.10332468 ## [8,] -0.715348680 -1.18478352 -0.48014129 0.02912626 ## [9,] 0.505443630 -0.09157295 -1.50685952 -0.66557267 ## [10,] -0.599432472 1.48268666 1.05511580 -1.15906970 ## ## , , 3 ## ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] -1.3732460 0.021415364 -0.3906025 -2.7058192 -1.45171710 1.7557476 ## [2,] 1.4888439 -1.487715392 -0.7089114 0.4317893 -2.62432103 0.8068537 ## [3,] -1.4322249 -0.437727643 0.6434365 -0.8073410 -0.04293109 -1.0333085 ## [4,] -1.7586200 -0.002297155 -0.7120490 -1.0109165 -1.44688522 0.3193732 ## [5,] 0.4328436 -1.424505015 -1.6111367 0.3977470 -0.50031418 -1.2076169 ## [6,] -0.7535017 1.550980636 -0.5502882 0.1832175 -0.07420429 -0.8628328 ## [7,] 0.4699004 -0.097062967 -1.1192699 1.0212204 -0.03143848 -0.9597520 ## [8,] -1.2594020 1.427516933 -1.0313822 -0.6785647 1.17613959 -1.6402231 ## [9,] -0.1427219 -0.661148022 -1.2574248 0.4766093 0.32237798 -0.5777912 ## [10,] 0.1869222 -0.905112421 -0.2712758 1.7689729 1.29369624 0.2265735 ## [,7] [,8] [,9] [,10] ## [1,] -1.24316557 -0.156613777 1.752430617 0.02106669 ## [2,] -0.08577327 -0.880176727 0.058304598 0.72586438 ## [3,] -0.45418927 -0.428317267 0.741641103 -0.65523307 ## [4,] -0.27022270 0.726271027 0.148928579 -0.28273388 ## [5,] -0.91963811 -1.009282561 -0.365472340 -0.62752681 ## [6,] 1.04011014 -0.746137540 -0.004740181 -2.09440811 ## [7,] 0.44955872 0.066110560 0.235018208 -0.34923171 ## [8,] 0.67709330 -0.432205827 -0.009628248 -1.61508482 ## [9,] 1.26045539 -0.005826691 1.139785692 0.06243982 ## [10,] 0.03986455 0.051586585 -1.005351684 -0.75010713 Pourquoi s’embêter avec ça ? Parce qu’on peut appliquer des fonctions facilement sur les lignes, colonnes et autres dimensions. Exemple : résultats de validations croisées par bloc, simulations de loi selon différents paramètres. Et on calcule facilement des statistiques “marginales.” apply(arr,MARGIN = 3,FUN=mean) ## [1] -0.13388812 0.06162972 -0.25835963 apply(arr,MARGIN = c(2,3),FUN = mean) ## [,1] [,2] [,3] ## [1,] -0.17358882 0.15925808 -0.41412063 ## [2,] -0.09980413 -0.04393274 -0.20156557 ## [3,] 0.27852830 0.38256280 -0.70089041 ## [4,] -0.44425054 -0.04072201 -0.09230849 ## [5,] -0.75176223 0.28657492 -0.33795976 ## [6,] -0.20036369 0.55154224 -0.31729766 ## [7,] 0.09706973 -0.03700203 0.04940932 ## [8,] -0.02891373 0.08878418 -0.28145922 ## [9,] -0.10421851 -0.50266674 0.26909163 ## [10,] 0.08842242 -0.22810150 -0.55649546 Le coin du capitaine [ ] Le crochet, c’est comme le capitaine du même nom : personne ne l’aime, mais sans lui, pas de Peter Pan, pas de Neverland ! Moralité, on s’en sert beacoup pour pimenter les codes ! On peut utiliser les crochets pour accéder aux éléments des matrices/arrays et dataframe/listes. Matrices et arrays mat[1,1] ## [1] 0.3206636 mat[1,] ## [1] 0.3206636 1.9342617 -1.0209712 1.5196376 -0.6048083 -1.0266147 ## [7] -2.3506341 0.9432069 0.1855897 -0.8142976 mat[,1] ## [1] 0.32066363 0.52310197 1.95463151 1.20640703 -1.08773672 -1.37512318 ## [7] -1.84662797 -1.06825212 -0.16996945 -0.04904652 arr[1,1,1] ## [1] 2.135165 arr[1,,] ## [,1] [,2] [,3] ## [1,] 2.1351655 0.1229457 -1.37324596 ## [2,] 0.1338073 -0.7896653 0.02141536 ## [3,] 1.1596237 -0.4220682 -0.39060250 ## [4,] 0.9365680 -0.5600118 -2.70581919 ## [5,] -1.1207742 -1.3805948 -1.45171710 ## [6,] 0.4544554 0.1390291 1.75574764 ## [7,] -0.8845087 0.7009159 -1.24316557 ## [8,] 0.5794699 0.7528262 -0.15661378 ## [9,] 0.1582721 -1.0491103 1.75243062 ## [10,] -0.6804929 1.0498949 0.02106669 arr[,,1] ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 2.1351655 0.13380731 1.15962369 0.9365680 -1.1207742 0.45445540 ## [2,] -2.1661246 -1.44348480 -0.43543464 -1.4348564 -0.8925491 -1.20521878 ## [3,] -0.7449696 -0.03254835 0.64725054 -0.5766552 0.7865341 -1.08271653 ## [4,] -0.8158185 -0.31306207 -1.75313718 1.3809233 -1.1213476 -0.78642393 ## [5,] -0.1481436 0.32852426 1.40409854 -1.1452945 -1.1525760 0.40795577 ## [6,] -0.6323061 0.75680619 -0.34263728 -2.1331954 -0.2997279 0.76150667 ## [7,] 1.4462024 -0.45378663 0.54896418 0.5836715 -0.3369027 0.46020660 ## [8,] -0.8825424 -0.56472615 1.05199269 -0.9600739 -0.7677224 -1.56848590 ## [9,] 0.4013431 0.09958858 0.03105386 0.1758877 -0.6666842 0.48881393 ## [10,] -0.3286944 0.49084039 0.47350858 -1.2694805 -1.9458723 0.06626985 ## [,7] [,8] [,9] [,10] ## [1,] -0.8845087 0.57946986 0.1582721 -0.68049285 ## [2,] 1.2920075 1.98136714 0.8233524 0.09804576 ## [3,] 1.2791096 0.30123281 0.2328240 -0.48961287 ## [4,] 0.3604145 -0.09609509 -0.6905764 0.78758126 ## [5,] -0.2100855 0.44322758 -0.7703918 -0.17091149 ## [6,] 0.1988000 -0.42518433 -0.8025606 0.43134272 ## [7,] -1.0756127 0.20038058 0.4257759 0.99396373 ## [8,] 1.1161335 -1.04467844 0.1076472 -1.03620745 ## [9,] -0.6641683 -0.72420753 0.3178149 0.27491803 ## [10,] -0.4413926 -1.50464985 -0.8443428 0.67559733 dataframes et listes : Pour les dataframes, le fonctionnement est le même que pour les matrices. Pour les listes, une paire de crochet renvoie un résultat sous forme de liste, un double crochet renvoie le résultat sous sa forme naturelle (ex : vecteur ou matrice). str(liste[1]) ## List of 1 ## $ vtaille: Factor w/ 2 levels &quot;L&quot;,&quot;S&quot;: 2 1 2 1 2 1 2 1 2 1 str(liste[[1]]) ## Factor w/ 2 levels &quot;L&quot;,&quot;S&quot;: 2 1 2 1 2 1 2 1 2 1 11.1.3 Inspection d’un objet : la régression La régression linéaire consiste à exprimer une variable Y en fonction d’une variable X dans une fonction linéaire. C’est à dire qu’on cherche a et b tels que : \\[ Y = a \\cdot X + b + \\epsilon\\] où \\(\\epsilon\\) est le résidu de la régression. On utilise dans cet exemple la table des iris de Fisher, existant dans R base qu’il suffit d’appeler avec data(iris) (il existe d’autres dataframe inclus dans les packages et qui sont utilisés en exemple dans l’aide). data(&quot;iris&quot;) str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... Faire la régression de la Sepal.Length sur Petal.length à l’aide de la fonction lm() lm(data=iris,formula = Sepal.Length~Petal.Length) ## ## Call: ## lm(formula = Sepal.Length ~ Petal.Length, data = iris) ## ## Coefficients: ## (Intercept) Petal.Length ## 4.3066 0.4089 On a les paramètres a et b mais on aimerait en savoir plus… Au moins la qualité d’ajustement (le \\(R^2\\) par exemple), et un graphique des résidus pour détecter une éventuelle structure. Pour cela, stocker le résultat dans un nouvel objet, et explorez-le avec les fonctions str(), summary() et plot() reg &lt;- lm(data=iris,formula = Sepal.Length~Petal.Length) str(reg) ## List of 12 ## $ coefficients : Named num [1:2] 4.307 0.409 ## ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;(Intercept)&quot; &quot;Petal.Length&quot; ## $ residuals : Named num [1:150] 0.2209 0.0209 -0.1382 -0.32 0.1209 ... ## ..- attr(*, &quot;names&quot;)= chr [1:150] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ effects : Named num [1:150] -71.566 8.812 -0.155 -0.337 0.104 ... ## ..- attr(*, &quot;names&quot;)= chr [1:150] &quot;(Intercept)&quot; &quot;Petal.Length&quot; &quot;&quot; &quot;&quot; ... ## $ rank : int 2 ## $ fitted.values: Named num [1:150] 4.88 4.88 4.84 4.92 4.88 ... ## ..- attr(*, &quot;names&quot;)= chr [1:150] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ assign : int [1:2] 0 1 ## $ qr :List of 5 ## ..$ qr : num [1:150, 1:2] -12.2474 0.0816 0.0816 0.0816 0.0816 ... ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : chr [1:150] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## .. .. ..$ : chr [1:2] &quot;(Intercept)&quot; &quot;Petal.Length&quot; ## .. ..- attr(*, &quot;assign&quot;)= int [1:2] 0 1 ## ..$ qraux: num [1:2] 1.08 1.1 ## ..$ pivot: int [1:2] 1 2 ## ..$ tol : num 1e-07 ## ..$ rank : int 2 ## ..- attr(*, &quot;class&quot;)= chr &quot;qr&quot; ## $ df.residual : int 148 ## $ xlevels : Named list() ## $ call : language lm(formula = Sepal.Length ~ Petal.Length, data = iris) ## $ terms :Classes &#39;terms&#39;, &#39;formula&#39; language Sepal.Length ~ Petal.Length ## .. ..- attr(*, &quot;variables&quot;)= language list(Sepal.Length, Petal.Length) ## .. ..- attr(*, &quot;factors&quot;)= int [1:2, 1] 0 1 ## .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. ..$ : chr [1:2] &quot;Sepal.Length&quot; &quot;Petal.Length&quot; ## .. .. .. ..$ : chr &quot;Petal.Length&quot; ## .. ..- attr(*, &quot;term.labels&quot;)= chr &quot;Petal.Length&quot; ## .. ..- attr(*, &quot;order&quot;)= int 1 ## .. ..- attr(*, &quot;intercept&quot;)= int 1 ## .. ..- attr(*, &quot;response&quot;)= int 1 ## .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; ## .. ..- attr(*, &quot;predvars&quot;)= language list(Sepal.Length, Petal.Length) ## .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:2] &quot;numeric&quot; &quot;numeric&quot; ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Sepal.Length&quot; &quot;Petal.Length&quot; ## $ model :&#39;data.frame&#39;: 150 obs. of 2 variables: ## ..$ Sepal.Length: num [1:150] 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## ..$ Petal.Length: num [1:150] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## ..- attr(*, &quot;terms&quot;)=Classes &#39;terms&#39;, &#39;formula&#39; language Sepal.Length ~ Petal.Length ## .. .. ..- attr(*, &quot;variables&quot;)= language list(Sepal.Length, Petal.Length) ## .. .. ..- attr(*, &quot;factors&quot;)= int [1:2, 1] 0 1 ## .. .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. .. ..$ : chr [1:2] &quot;Sepal.Length&quot; &quot;Petal.Length&quot; ## .. .. .. .. ..$ : chr &quot;Petal.Length&quot; ## .. .. ..- attr(*, &quot;term.labels&quot;)= chr &quot;Petal.Length&quot; ## .. .. ..- attr(*, &quot;order&quot;)= int 1 ## .. .. ..- attr(*, &quot;intercept&quot;)= int 1 ## .. .. ..- attr(*, &quot;response&quot;)= int 1 ## .. .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; ## .. .. ..- attr(*, &quot;predvars&quot;)= language list(Sepal.Length, Petal.Length) ## .. .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:2] &quot;numeric&quot; &quot;numeric&quot; ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Sepal.Length&quot; &quot;Petal.Length&quot; ## - attr(*, &quot;class&quot;)= chr &quot;lm&quot; summary(reg) ## ## Call: ## lm(formula = Sepal.Length ~ Petal.Length, data = iris) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.24675 -0.29657 -0.01515 0.27676 1.00269 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 4.30660 0.07839 54.94 &lt;2e-16 *** ## Petal.Length 0.40892 0.01889 21.65 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.4071 on 148 degrees of freedom ## Multiple R-squared: 0.76, Adjusted R-squared: 0.7583 ## F-statistic: 468.6 on 1 and 148 DF, p-value: &lt; 2.2e-16 plot(reg) Les méthodes summary, print et plot sont implémentées pour tous les objets en R, et on peut les utiliser pour avoir un premier aperçu de ce que l’on obtient avec la fonction. 11.2 Premier jeu de données, premières statistiques 11.2.1 Importer les données et premier coup d’oeil On peut importer n’importe quel format de données en R (excel, sas, stata, SQL…) et ceci est abordé dans le module 2. Pour ce module, nous ne voyons que l’importation de fichier .CSV. Si vous avez une base de données en excel ou libreOffice, sauvegardez l’onglet que vous souhaitez en faisant “enregistrer sous” \\(\\rightarrow\\) “délimité CSV.” Ici, nous travaillerons sur une base de données communales fournies par l’Insee, dite “comparateur de territoires.” Le fichier (excel) source figure sous le répertoire “data” et contient toutes les métadonnées ; nous avons ajouté une colonne correspondant au type ZAU de la commune concernée. Utilisez la fonction read.csv pour importer ce fichier et stockez le dans un objet df. Veillez à ce que la région soit bien importée comme un facteur et non un entier. Inspectez ce nouvel objet. df &lt;- read.csv(file = &quot;./data/Base_synth_territoires.csv&quot;,sep=&quot;;&quot;,dec=&quot;,&quot;) str(df) ## &#39;data.frame&#39;: 36689 obs. of 38 variables: ## $ CODGEO : chr &quot;01001&quot; &quot;01002&quot; &quot;01004&quot; &quot;01005&quot; ... ## $ LIBGEO : chr &quot;L&#39;Abergement-Cl\\xe9menciat&quot; &quot;L&#39;Abergement-de-Varey&quot; &quot;Amb\\xe9rieu-en-Bugey&quot; &quot;Amb\\xe9rieux-en-Dombes&quot; ... ## $ REG : int 84 84 84 84 84 84 84 84 84 84 ... ## $ DEP : chr &quot;01&quot; &quot;01&quot; &quot;01&quot; &quot;01&quot; ... ## $ ZAU : chr &quot;120 - Multipolaris\\xe9e des grandes aires urbaines&quot; &quot;112 - Couronne d&#39;un grand p\\xf4le&quot; &quot;112 - Couronne d&#39;un grand p\\xf4le&quot; &quot;112 - Couronne d&#39;un grand p\\xf4le&quot; ... ## $ ZE : chr &quot;8213 - Villefranche-sur-Sa\\xf4ne&quot; &quot;8201 - Amb\\xe9rieu-en-Bugey&quot; &quot;8201 - Amb\\xe9rieu-en-Bugey&quot; &quot;8213 - Villefranche-sur-Sa\\xf4ne&quot; ... ## $ P14_POP : int 767 239 14022 1627 109 2570 743 338 1142 397 ... ## $ P09_POP : int 787 207 13350 1592 120 2328 660 336 960 352 ... ## $ SUPERF : num 15.95 9.15 24.6 15.92 5.88 ... ## $ NAIS0914 : int 40 16 1051 117 8 175 59 12 56 25 ... ## $ DECE0914 : int 25 7 551 41 3 78 20 11 32 10 ... ## $ P14_MEN : num 306 99.3 6161.1 621.1 52.5 ... ## $ NAISD15 : int 13 5 222 15 2 21 11 2 18 4 ... ## $ DECESD15 : int 5 1 121 7 2 9 3 3 5 0 ... ## $ P14_LOG : num 342.7 161.2 6838.4 661.8 71.5 ... ## $ P14_RP : num 306 99.3 6161.1 621.1 52.5 ... ## $ P14_RSECOCC : num 14 47.3 121.6 10.9 10.9 ... ## $ P14_LOGVAC : num 22.74 14.55 555.64 29.85 8.14 ... ## $ P14_RP_PROP : num 260 84.6 2769 473.3 37.7 ... ## $ NBMENFISC13 : int 297 99 6034 617 47 1014 299 140 431 137 ... ## $ PIMP13 : num NA NA 57.4 NA NA ... ## $ MED13 : num 22130 23213 19554 22388 21872 ... ## $ TP6013 : num NA NA 15.1 NA NA ... ## $ P14_EMPLT : num 85.16 12.81 7452.93 280.57 5.95 ... ## $ P14_EMPLT_SAL: num 52.19 4.95 6743.37 206.38 3.96 ... ## $ P09_EMPLT : num 65.57 17.64 7551.68 286.61 5.29 ... ## $ P14_POP1564 : num 463 141.6 8962.8 1043.1 71.3 ... ## $ P14_CHOM1564 : num 33 9.84 1059.73 66.33 7.93 ... ## $ P14_ACT1564 : num 376 121 6681.9 842.1 57.5 ... ## $ ETTOT14 : int 47 22 1316 141 7 203 66 39 54 36 ... ## $ ETAZ14 : int 9 1 7 14 0 21 2 5 5 6 ... ## $ ETBE14 : int 2 3 60 7 0 18 0 2 6 4 ... ## $ ETFZ14 : int 5 1 131 19 0 21 9 1 13 3 ... ## $ ETGU14 : int 25 14 892 85 5 114 45 27 24 18 ... ## $ ETGZ14 : int 6 4 283 19 1 28 16 6 9 7 ... ## $ ETOQ14 : int 6 3 226 16 2 29 10 4 6 5 ... ## $ ETTEF114 : int 9 2 385 27 0 38 17 6 9 7 ... ## $ ETTEFP1014 : int 0 0 109 5 0 15 2 0 3 0 ... df &lt;- read.csv(file = &quot;./data/Base_synth_territoires.csv&quot;,sep=&quot;;&quot;,dec=&quot;,&quot;,colClasses = c(&quot;REG&quot;=&quot;factor&quot;)) str(df) ## &#39;data.frame&#39;: 36689 obs. of 38 variables: ## $ CODGEO : chr &quot;01001&quot; &quot;01002&quot; &quot;01004&quot; &quot;01005&quot; ... ## $ LIBGEO : chr &quot;L&#39;Abergement-Cl\\xe9menciat&quot; &quot;L&#39;Abergement-de-Varey&quot; &quot;Amb\\xe9rieu-en-Bugey&quot; &quot;Amb\\xe9rieux-en-Dombes&quot; ... ## $ REG : Factor w/ 17 levels &quot;01&quot;,&quot;02&quot;,&quot;03&quot;,..: 15 15 15 15 15 15 15 15 15 15 ... ## $ DEP : chr &quot;01&quot; &quot;01&quot; &quot;01&quot; &quot;01&quot; ... ## $ ZAU : chr &quot;120 - Multipolaris\\xe9e des grandes aires urbaines&quot; &quot;112 - Couronne d&#39;un grand p\\xf4le&quot; &quot;112 - Couronne d&#39;un grand p\\xf4le&quot; &quot;112 - Couronne d&#39;un grand p\\xf4le&quot; ... ## $ ZE : chr &quot;8213 - Villefranche-sur-Sa\\xf4ne&quot; &quot;8201 - Amb\\xe9rieu-en-Bugey&quot; &quot;8201 - Amb\\xe9rieu-en-Bugey&quot; &quot;8213 - Villefranche-sur-Sa\\xf4ne&quot; ... ## $ P14_POP : int 767 239 14022 1627 109 2570 743 338 1142 397 ... ## $ P09_POP : int 787 207 13350 1592 120 2328 660 336 960 352 ... ## $ SUPERF : num 15.95 9.15 24.6 15.92 5.88 ... ## $ NAIS0914 : int 40 16 1051 117 8 175 59 12 56 25 ... ## $ DECE0914 : int 25 7 551 41 3 78 20 11 32 10 ... ## $ P14_MEN : num 306 99.3 6161.1 621.1 52.5 ... ## $ NAISD15 : int 13 5 222 15 2 21 11 2 18 4 ... ## $ DECESD15 : int 5 1 121 7 2 9 3 3 5 0 ... ## $ P14_LOG : num 342.7 161.2 6838.4 661.8 71.5 ... ## $ P14_RP : num 306 99.3 6161.1 621.1 52.5 ... ## $ P14_RSECOCC : num 14 47.3 121.6 10.9 10.9 ... ## $ P14_LOGVAC : num 22.74 14.55 555.64 29.85 8.14 ... ## $ P14_RP_PROP : num 260 84.6 2769 473.3 37.7 ... ## $ NBMENFISC13 : int 297 99 6034 617 47 1014 299 140 431 137 ... ## $ PIMP13 : num NA NA 57.4 NA NA ... ## $ MED13 : num 22130 23213 19554 22388 21872 ... ## $ TP6013 : num NA NA 15.1 NA NA ... ## $ P14_EMPLT : num 85.16 12.81 7452.93 280.57 5.95 ... ## $ P14_EMPLT_SAL: num 52.19 4.95 6743.37 206.38 3.96 ... ## $ P09_EMPLT : num 65.57 17.64 7551.68 286.61 5.29 ... ## $ P14_POP1564 : num 463 141.6 8962.8 1043.1 71.3 ... ## $ P14_CHOM1564 : num 33 9.84 1059.73 66.33 7.93 ... ## $ P14_ACT1564 : num 376 121 6681.9 842.1 57.5 ... ## $ ETTOT14 : int 47 22 1316 141 7 203 66 39 54 36 ... ## $ ETAZ14 : int 9 1 7 14 0 21 2 5 5 6 ... ## $ ETBE14 : int 2 3 60 7 0 18 0 2 6 4 ... ## $ ETFZ14 : int 5 1 131 19 0 21 9 1 13 3 ... ## $ ETGU14 : int 25 14 892 85 5 114 45 27 24 18 ... ## $ ETGZ14 : int 6 4 283 19 1 28 16 6 9 7 ... ## $ ETOQ14 : int 6 3 226 16 2 29 10 4 6 5 ... ## $ ETTEF114 : int 9 2 385 27 0 38 17 6 9 7 ... ## $ ETTEFP1014 : int 0 0 109 5 0 15 2 0 3 0 ... Inspectez le dataframe avec les fonctions vues en cours… et plus ! dim(df) ## [1] 36689 38 head(df) ## CODGEO LIBGEO REG DEP ## 1 01001 L&#39;Abergement-Cl\\xe9menciat 84 01 ## 2 01002 L&#39;Abergement-de-Varey 84 01 ## 3 01004 Amb\\xe9rieu-en-Bugey 84 01 ## 4 01005 Amb\\xe9rieux-en-Dombes 84 01 ## 5 01006 Ambl\\xe9on 84 01 ## 6 01007 Ambronay 84 01 ## ZAU ## 1 120 - Multipolaris\\xe9e des grandes aires urbaines ## 2 112 - Couronne d&#39;un grand p\\xf4le ## 3 112 - Couronne d&#39;un grand p\\xf4le ## 4 112 - Couronne d&#39;un grand p\\xf4le ## 5 300 - Autre commune multipolaris\\xe9e ## 6 112 - Couronne d&#39;un grand p\\xf4le ## ZE P14_POP P09_POP SUPERF NAIS0914 DECE0914 ## 1 8213 - Villefranche-sur-Sa\\xf4ne 767 787 15.95 40 25 ## 2 8201 - Amb\\xe9rieu-en-Bugey 239 207 9.15 16 7 ## 3 8201 - Amb\\xe9rieu-en-Bugey 14022 13350 24.60 1051 551 ## 4 8213 - Villefranche-sur-Sa\\xf4ne 1627 1592 15.92 117 41 ## 5 8216 - Chamb\\xe9ry 109 120 5.88 8 3 ## 6 8201 - Amb\\xe9rieu-en-Bugey 2570 2328 33.55 175 78 ## P14_MEN NAISD15 DECESD15 P14_LOG P14_RP P14_RSECOCC P14_LOGVAC ## 1 306.00000 13 5 342.73473 306.00000 13.99418 22.740550 ## 2 99.33745 5 1 161.16023 99.33745 47.27625 14.546538 ## 3 6161.06200 222 121 6838.35437 6161.06200 121.64795 555.644416 ## 4 621.05374 15 7 661.76017 621.05374 10.85505 29.851387 ## 5 52.51818 2 2 71.51818 52.51818 10.85714 8.142857 ## 6 1028.00000 21 9 1160.00000 1028.00000 56.00000 76.000000 ## P14_RP_PROP NBMENFISC13 PIMP13 MED13 TP6013 P14_EMPLT P14_EMPLT_SAL ## 1 260.00000 297 NA 22130.00 NA 85.157286 52.191539 ## 2 84.58436 99 NA 23213.00 NA 12.814642 4.946329 ## 3 2769.00170 6034 57.41294 19554.00 15.11508 7452.926728 6743.374287 ## 4 473.32736 617 NA 22387.62 NA 280.569953 206.382233 ## 5 37.65455 47 NA 21871.67 NA 5.945455 3.963636 ## 6 779.00000 1014 62.35178 21650.67 NA 487.730918 372.758450 ## P09_EMPLT P14_POP1564 P14_CHOM1564 P14_ACT1564 ETTOT14 ETAZ14 ETBE14 ETFZ14 ## 1 65.566193 463.00000 33.000000 376.00000 47 9 2 5 ## 2 17.644456 141.62963 9.835391 120.97531 22 1 3 1 ## 3 7551.682296 8962.84216 1059.728437 6681.86216 1316 7 60 131 ## 4 286.611037 1043.12909 66.326127 842.14083 141 14 7 19 ## 5 5.285714 71.34545 7.927273 57.47273 7 0 0 0 ## 6 491.138876 1614.00000 108.000000 1267.00000 203 21 18 21 ## ETGU14 ETGZ14 ETOQ14 ETTEF114 ETTEFP1014 ## 1 25 6 6 9 0 ## 2 14 4 3 2 0 ## 3 892 283 226 385 109 ## 4 85 19 16 27 5 ## 5 5 1 2 0 0 ## 6 114 28 29 38 15 tail(df) ## CODGEO LIBGEO REG DEP ## 36684 97419 Sainte-Rose 04 974 ## 36685 97420 Sainte-Suzanne 04 974 ## 36686 97421 Salazie 04 974 ## 36687 97422 Le Tampon 04 974 ## 36688 97423 Les Trois-Bassins 04 974 ## 36689 97424 Cilaos 04 974 ## ZAU ZE ## 36684 400 - Commune isol\\xe9e hors influence des p\\xf4les 0401 - L&#39;Est ## 36685 112 - Couronne d&#39;un grand p\\xf4le 0402 - Le Nord ## 36686 400 - Commune isol\\xe9e hors influence des p\\xf4les 0401 - L&#39;Est ## 36687 111 - Grand p\\xf4le (plus de 10 000 emplois) 0404 - Le Sud ## 36688 112 - Couronne d&#39;un grand p\\xf4le 0403 - L&#39;Ouest ## 36689 400 - Commune isol\\xe9e hors influence des p\\xf4les 0404 - Le Sud ## P14_POP P09_POP SUPERF NAIS0914 DECE0914 P14_MEN NAISD15 DECESD15 ## 36684 6722 6822 177.60 519 186 2322.000 94 43 ## 36685 22406 22437 57.84 1963 508 7686.912 358 100 ## 36686 7132 7406 103.82 661 235 2420.000 111 46 ## 36687 76796 72658 165.43 6663 2004 29662.460 1339 420 ## 36688 7198 7057 42.58 531 217 2484.887 104 54 ## 36689 5295 5989 84.40 430 186 2016.000 87 38 ## P14_LOG P14_RP P14_RSECOCC P14_LOGVAC P14_RP_PROP NBMENFISC13 PIMP13 ## 36684 2542.478 2322.000 28.58054 191.8979 1799.954 NA NA ## 36685 8328.616 7686.912 50.94097 590.7629 4450.648 NA NA ## 36686 2987.000 2420.000 174.00000 393.0000 1849.000 NA NA ## 36687 32710.091 29662.460 1004.31703 2043.3140 15372.921 NA NA ## 36688 2890.404 2484.887 67.58626 337.9313 1773.765 NA NA ## 36689 2732.690 2016.000 239.56501 477.1253 1522.480 NA NA ## MED13 TP6013 P14_EMPLT P14_EMPLT_SAL P09_EMPLT P14_POP1564 P14_CHOM1564 ## 36684 NA NA 1272.841 920.0617 1269.573 4306.217 1250.516 ## 36685 NA NA 4296.362 3618.1538 4185.015 14821.042 3712.486 ## 36686 NA NA 1519.306 1090.0856 1533.305 4650.000 1369.000 ## 36687 NA NA 16145.620 12486.5465 14807.249 50316.640 12783.137 ## 36688 NA NA 1273.858 994.3469 1202.079 4850.570 1360.617 ## 36689 NA NA 1194.383 993.1546 1314.121 3461.457 1122.361 ## P14_ACT1564 ETTOT14 ETAZ14 ETBE14 ETFZ14 ETGU14 ETGZ14 ETOQ14 ETTEF114 ## 36684 2850.155 414 125 44 31 159 59 55 82 ## 36685 10456.196 1323 136 139 190 694 249 164 267 ## 36686 3108.000 490 148 29 43 214 73 56 95 ## 36687 34446.789 5476 565 398 665 3025 999 823 1032 ## 36688 3524.287 456 42 39 61 223 76 91 59 ## 36689 2415.666 360 49 17 35 193 49 66 65 ## ETTEFP1014 ## 36684 8 ## 36685 66 ## 36686 11 ## 36687 204 ## 36688 20 ## 36689 26 str(df) ## &#39;data.frame&#39;: 36689 obs. of 38 variables: ## $ CODGEO : chr &quot;01001&quot; &quot;01002&quot; &quot;01004&quot; &quot;01005&quot; ... ## $ LIBGEO : chr &quot;L&#39;Abergement-Cl\\xe9menciat&quot; &quot;L&#39;Abergement-de-Varey&quot; &quot;Amb\\xe9rieu-en-Bugey&quot; &quot;Amb\\xe9rieux-en-Dombes&quot; ... ## $ REG : Factor w/ 17 levels &quot;01&quot;,&quot;02&quot;,&quot;03&quot;,..: 15 15 15 15 15 15 15 15 15 15 ... ## $ DEP : chr &quot;01&quot; &quot;01&quot; &quot;01&quot; &quot;01&quot; ... ## $ ZAU : chr &quot;120 - Multipolaris\\xe9e des grandes aires urbaines&quot; &quot;112 - Couronne d&#39;un grand p\\xf4le&quot; &quot;112 - Couronne d&#39;un grand p\\xf4le&quot; &quot;112 - Couronne d&#39;un grand p\\xf4le&quot; ... ## $ ZE : chr &quot;8213 - Villefranche-sur-Sa\\xf4ne&quot; &quot;8201 - Amb\\xe9rieu-en-Bugey&quot; &quot;8201 - Amb\\xe9rieu-en-Bugey&quot; &quot;8213 - Villefranche-sur-Sa\\xf4ne&quot; ... ## $ P14_POP : int 767 239 14022 1627 109 2570 743 338 1142 397 ... ## $ P09_POP : int 787 207 13350 1592 120 2328 660 336 960 352 ... ## $ SUPERF : num 15.95 9.15 24.6 15.92 5.88 ... ## $ NAIS0914 : int 40 16 1051 117 8 175 59 12 56 25 ... ## $ DECE0914 : int 25 7 551 41 3 78 20 11 32 10 ... ## $ P14_MEN : num 306 99.3 6161.1 621.1 52.5 ... ## $ NAISD15 : int 13 5 222 15 2 21 11 2 18 4 ... ## $ DECESD15 : int 5 1 121 7 2 9 3 3 5 0 ... ## $ P14_LOG : num 342.7 161.2 6838.4 661.8 71.5 ... ## $ P14_RP : num 306 99.3 6161.1 621.1 52.5 ... ## $ P14_RSECOCC : num 14 47.3 121.6 10.9 10.9 ... ## $ P14_LOGVAC : num 22.74 14.55 555.64 29.85 8.14 ... ## $ P14_RP_PROP : num 260 84.6 2769 473.3 37.7 ... ## $ NBMENFISC13 : int 297 99 6034 617 47 1014 299 140 431 137 ... ## $ PIMP13 : num NA NA 57.4 NA NA ... ## $ MED13 : num 22130 23213 19554 22388 21872 ... ## $ TP6013 : num NA NA 15.1 NA NA ... ## $ P14_EMPLT : num 85.16 12.81 7452.93 280.57 5.95 ... ## $ P14_EMPLT_SAL: num 52.19 4.95 6743.37 206.38 3.96 ... ## $ P09_EMPLT : num 65.57 17.64 7551.68 286.61 5.29 ... ## $ P14_POP1564 : num 463 141.6 8962.8 1043.1 71.3 ... ## $ P14_CHOM1564 : num 33 9.84 1059.73 66.33 7.93 ... ## $ P14_ACT1564 : num 376 121 6681.9 842.1 57.5 ... ## $ ETTOT14 : int 47 22 1316 141 7 203 66 39 54 36 ... ## $ ETAZ14 : int 9 1 7 14 0 21 2 5 5 6 ... ## $ ETBE14 : int 2 3 60 7 0 18 0 2 6 4 ... ## $ ETFZ14 : int 5 1 131 19 0 21 9 1 13 3 ... ## $ ETGU14 : int 25 14 892 85 5 114 45 27 24 18 ... ## $ ETGZ14 : int 6 4 283 19 1 28 16 6 9 7 ... ## $ ETOQ14 : int 6 3 226 16 2 29 10 4 6 5 ... ## $ ETTEF114 : int 9 2 385 27 0 38 17 6 9 7 ... ## $ ETTEFP1014 : int 0 0 109 5 0 15 2 0 3 0 ... names(df) ## [1] &quot;CODGEO&quot; &quot;LIBGEO&quot; &quot;REG&quot; &quot;DEP&quot; ## [5] &quot;ZAU&quot; &quot;ZE&quot; &quot;P14_POP&quot; &quot;P09_POP&quot; ## [9] &quot;SUPERF&quot; &quot;NAIS0914&quot; &quot;DECE0914&quot; &quot;P14_MEN&quot; ## [13] &quot;NAISD15&quot; &quot;DECESD15&quot; &quot;P14_LOG&quot; &quot;P14_RP&quot; ## [17] &quot;P14_RSECOCC&quot; &quot;P14_LOGVAC&quot; &quot;P14_RP_PROP&quot; &quot;NBMENFISC13&quot; ## [21] &quot;PIMP13&quot; &quot;MED13&quot; &quot;TP6013&quot; &quot;P14_EMPLT&quot; ## [25] &quot;P14_EMPLT_SAL&quot; &quot;P09_EMPLT&quot; &quot;P14_POP1564&quot; &quot;P14_CHOM1564&quot; ## [29] &quot;P14_ACT1564&quot; &quot;ETTOT14&quot; &quot;ETAZ14&quot; &quot;ETBE14&quot; ## [33] &quot;ETFZ14&quot; &quot;ETGU14&quot; &quot;ETGZ14&quot; &quot;ETOQ14&quot; ## [37] &quot;ETTEF114&quot; &quot;ETTEFP1014&quot; class(df) ## [1] &quot;data.frame&quot; typeof(df) ## [1] &quot;list&quot; # Accéder a une variable directement (on obtient un vecteur) : df$CODGEO[1:10] # Captain crochet poweeeeerr !!! ## [1] &quot;01001&quot; &quot;01002&quot; &quot;01004&quot; &quot;01005&quot; &quot;01006&quot; &quot;01007&quot; &quot;01008&quot; &quot;01009&quot; &quot;01010&quot; ## [10] &quot;01011&quot; class(df$CODGEO) ## [1] &quot;character&quot; typeof(df$CODGEO) ## [1] &quot;character&quot; length(df) ## [1] 38 length(df$region) ## [1] 0 11.2.2 Créer, filtrer, sélectionner En utilisant la fonction mutate(), créer une nouvelle variable correspondant à la densité de population (rapport de la population à la superficie de la commune), ainsi que les taux de natalité et de mortalité (en pour mille) df &lt;- mutate(df,densite=P14_POP/SUPERF,tx_natal=1000*NAISD15/P14_POP,tx_mort=DECESD15/P14_POP) A l’aide de la fonction select(), créez une nouvelle table dans laquelle vous ne gardez que le code commune, le type de commune (ZAU), la région, le département et les variables que vous venez de créer. selection &lt;- select(df,CODGEO,ZAU,REG,DEP,densite,tx_natal,tx_mort) Enfin, ne retenez les communes correspondant à votre département de naissance et stocker. Faites attention au type de la variable département ! S0 &lt;- filter(selection,DEP==&quot;62&quot;) On va maintenant jouer avec les opérateurs logiques pour sélectionner des échantillons différents ! S1 &lt;- filter(selection,DEP!=&quot;62&quot;) # tout sauf le 62 :( S2 &lt;- filter(selection,DEP %in% c(&quot;59&quot;,&quot;62&quot;)) # L&#39;ancien NPdC :) S3 &lt;- filter(selection,!(DEP %in% c(&quot;59&quot;,&quot;62&quot;))) # Le &quot;sud&quot; de la France S4 &lt;- filter(selection,densite&gt;100) # l&#39;urbain S5 &lt;- filter(selection,DEP==&quot;62&quot; &amp; densite&gt;100) # le PdC urbain S6 &lt;- filter(selection, DEP==&quot;62&quot; | densite &gt; 100) # le PdC et l&#39;urbain Nom d’un pipe %&gt;% ! On peut combiner les opérations en une seule ligne à l’aide du pipe %&gt;% : selection &lt;- select(df,CODGEO,ZAU,REG,DEP,densite,tx_natal,tx_mort) %&gt;% filter(DEP==&quot;62&quot;) Le coin du capitaine [ ] Pour sélectionner les données, on peut également utiliser les crochets couplés aux dollars et aux c(), sans passer par les numéros de lignes et colonnes ! On rencontre assez souvent cette syntaxe sur les forums. selection &lt;- df[df$DEP==&quot;62&quot;,c(&quot;CODGEO&quot;,&quot;ZAU&quot;,&quot;REG&quot;,&quot;DEP&quot;,&quot;densite&quot;,&quot;tx_natal&quot;,&quot;tx_mort&quot;)] Note : dans la syntaxe tidyverse, on ne met pas (obligatoirement) de guillemets pour les noms de variable, alors qu’on le fait pour la version [ ] 11.3 Mes premiers graphiques et statistiques 11.3.1 Statistiques univariées Utilisez la fonction summary pour obtenir un résumé de l’ensemble des variables de la table df df &lt;- mutate(df,ZAU2=as.factor(substr(ZAU,1,3))) ### Parce que la variable originale est trop longue et caractères bizarres summary(df) ## CODGEO LIBGEO REG DEP ## Length:36689 Length:36689 44 : 5198 Length:36689 ## Class :character Class :character 76 : 4565 Class :character ## Mode :character Mode :character 75 : 4505 Mode :character ## 84 : 4189 ## 32 : 3838 ## 27 : 3831 ## (Other):10563 ## ZAU ZE P14_POP P09_POP ## Length:36689 Length:36689 Min. : 0 Min. : 0 ## Class :character Class :character 1st Qu.: 197 1st Qu.: 193 ## Mode :character Mode :character Median : 444 Median : 431 ## Mean : 1838 Mean : 1793 ## 3rd Qu.: 1110 3rd Qu.: 1072 ## Max. :2220445 Max. :2234105 ## NA&#39;s :821 NA&#39;s :821 ## SUPERF NAIS0914 DECE0914 P14_MEN ## Min. : 0.04 Min. : 0.0 Min. : 0.00 Min. : 0.0 ## 1st Qu.: 6.44 1st Qu.: 9.0 1st Qu.: 8.00 1st Qu.: 83.8 ## Median : 10.81 Median : 23.0 Median : 17.00 Median : 183.2 ## Mean : 17.64 Mean : 114.4 Mean : 77.35 Mean : 802.0 ## 3rd Qu.: 18.58 3rd Qu.: 60.0 3rd Qu.: 43.00 3rd Qu.: 454.9 ## Max. :18360.00 Max. :150843.0 Max. :69907.00 Max. :1147990.9 ## NA&#39;s :821 NA&#39;s :821 NA&#39;s :821 NA&#39;s :821 ## NAISD15 DECESD15 P14_LOG P14_RP ## Min. : 0.00 Min. : 0.00 Min. : 0.0 Min. : 0.0 ## 1st Qu.: 1.00 1st Qu.: 1.00 1st Qu.: 115.0 1st Qu.: 83.8 ## Median : 4.00 Median : 3.00 Median : 239.1 Median : 183.2 ## Mean : 21.96 Mean : 16.47 Mean : 970.2 Mean : 802.0 ## 3rd Qu.: 11.00 3rd Qu.: 9.00 3rd Qu.: 565.0 3rd Qu.: 454.9 ## Max. :28267.00 Max. :13997.00 Max. :1362181.9 Max. :1147990.9 ## NA&#39;s :821 NA&#39;s :821 NA&#39;s :821 NA&#39;s :821 ## P14_RSECOCC P14_LOGVAC P14_RP_PROP NBMENFISC13 ## Min. : 0.00 Min. : 0.00 Min. : 0.0 Min. : 32.0 ## 1st Qu.: 7.00 1st Qu.: 8.00 1st Qu.: 68.4 1st Qu.: 102.0 ## Median : 19.00 Median : 18.00 Median : 148.0 Median : 205.0 ## Mean : 91.63 Mean : 76.60 Mean : 462.2 Mean : 809.7 ## 3rd Qu.: 49.29 3rd Qu.: 43.75 3rd Qu.: 349.2 3rd Qu.: 484.0 ## Max. :107061.99 Max. :107129.02 Max. :381934.3 Max. :1038789.0 ## NA&#39;s :821 NA&#39;s :821 NA&#39;s :821 NA&#39;s :3793 ## PIMP13 MED13 TP6013 P14_EMPLT ## Min. :24.46 Min. :10021 Min. : 5.00 Min. : 0.0 ## 1st Qu.:50.57 1st Qu.:18452 1st Qu.: 8.73 1st Qu.: 26.0 ## Median :58.40 Median :19844 Median :11.97 Median : 66.8 ## Mean :58.98 Mean :20250 Mean :13.35 Mean : 733.9 ## 3rd Qu.:67.19 3rd Qu.:21563 3rd Qu.:16.80 3rd Qu.: 229.5 ## Max. :89.38 Max. :46251 Max. :44.84 Max. :1801865.8 ## NA&#39;s :31598 NA&#39;s :3793 NA&#39;s :32531 NA&#39;s :821 ## P14_EMPLT_SAL P09_EMPLT P14_POP1564 ## Min. : 0.0 Min. : 0.0 Min. : 0.0 ## 1st Qu.: 13.0 1st Qu.: 26.1 1st Qu.: 120.3 ## Median : 42.0 Median : 65.2 Median : 275.0 ## Mean : 637.8 Mean : 716.4 Mean : 1165.0 ## 3rd Qu.: 173.4 3rd Qu.: 220.6 3rd Qu.: 684.8 ## Max. :1562078.5 Max. :1805470.4 Max. :1554076.1 ## NA&#39;s :821 NA&#39;s :9 NA&#39;s :821 ## P14_CHOM1564 P14_ACT1564 ETTOT14 ETAZ14 ## Min. : 0.00 Min. : 0.0 Min. : 0.0 Min. : 0.00 ## 1st Qu.: 8.85 1st Qu.: 90.5 1st Qu.: 19.0 1st Qu.: 4.00 ## Median : 20.45 Median : 208.3 Median : 38.0 Median : 7.00 ## Mean : 119.75 Mean : 855.8 Mean : 179.3 Mean : 11.36 ## 3rd Qu.: 51.78 3rd Qu.: 518.0 3rd Qu.: 92.0 3rd Qu.: 14.00 ## Max. :144515.41 Max. :1202565.3 Max. :551952.0 Max. :587.00 ## NA&#39;s :821 NA&#39;s :821 NA&#39;s :25 NA&#39;s :25 ## ETBE14 ETFZ14 ETGU14 ETGZ14 ## Min. : 0.000 Min. : 0.00 Min. : 0.0 Min. : 0.00 ## 1st Qu.: 1.000 1st Qu.: 2.00 1st Qu.: 7.0 1st Qu.: 1.00 ## Median : 3.000 Median : 5.00 Median : 17.0 Median : 4.00 ## Mean : 9.417 Mean : 18.18 Mean : 116.1 Mean : 28.73 ## 3rd Qu.: 7.000 3rd Qu.: 12.00 3rd Qu.: 47.0 3rd Qu.: 13.00 ## Max. :15181.000 Max. :24528.00 Max. :462763.0 Max. :65004.00 ## NA&#39;s :25 NA&#39;s :25 NA&#39;s :25 NA&#39;s :25 ## ETOQ14 ETTEF114 ETTEFP1014 densite ## Min. : 0.00 Min. : 0.00 Min. : 0.00 Min. : 0.00 ## 1st Qu.: 2.00 1st Qu.: 4.00 1st Qu.: 0.00 1st Qu.: 18.59 ## Median : 4.00 Median : 8.00 Median : 1.00 Median : 40.35 ## Mean : 24.22 Mean : 41.33 Mean : 10.28 Mean : 160.15 ## 3rd Qu.: 10.00 3rd Qu.: 19.00 3rd Qu.: 4.00 3rd Qu.: 94.57 ## Max. :48893.00 Max. :124131.00 Max. :24527.00 Max. :27126.14 ## NA&#39;s :25 NA&#39;s :25 NA&#39;s :25 NA&#39;s :821 ## tx_natal tx_mort ZAU2 ## Min. : 0.000 Min. :0.0000 112 :12297 ## 1st Qu.: 5.679 1st Qu.:0.0044 400 : 7383 ## Median : 9.264 Median :0.0079 300 : 7021 ## Mean : 9.699 Mean :0.0093 120 : 3962 ## 3rd Qu.: 12.931 3rd Qu.:0.0124 111 : 3285 ## Max. :111.111 Max. :0.1577 221 : 888 ## NA&#39;s :827 NA&#39;s :827 (Other): 1853 Calculez maintenant les moyenne, médiane, écart-type et variance de la variable de densité de population mean(df$densite) ## [1] NA sd(df$densite) ## [1] NA median(df$densite) ## [1] NA var(df$densite) ## [1] NA Il y a des valeurs manquantes, qui sont absorbantes ! On ajoute un paramètre pour calculer uniquement sur les valeurs renseignées mean(df$densite,na.rm = T) ## [1] 160.151 sd(df$densite,na.rm = T) ## [1] 722.799 median(df$densite,na.rm = T) ## [1] 40.35457 var(df$densite,na.rm = T) ## [1] 522438.4 Application : calculez la version centrée réduite de la variable de densité. Rappel : on calcule la version centrée réduite d’une variable X en lui appliquant la transformation suivante : \\[ STD_X = \\dfrac{X-\\bar{X}}{\\sigma_X}\\] où \\(\\bar{X}\\) est la moyenne empirique de X et \\(\\sigma_X\\) son écart-type Avantage : on élimine les effets d’unité (d’ordre de grandeur) df &lt;- mutate(df,std_dens=(densite-mean(densite,na.rm = T))/sd(densite,na.rm = T)) mean(df$std_dens,na.rm = T) ## [1] 9.482279e-18 sd(df$std_dens, na.rm = T) ## [1] 1 Calulez à présent les quartiles puis déciles de cette variables quantile(df$densite,na.rm = T) ## 0% 25% 50% 75% 100% ## 0.00000 18.59047 40.35457 94.57430 27126.14108 quantile(df$densite,probs = seq(0,1,.1),na.rm = T) ## 0% 10% 20% 30% 40% 50% ## 0.00000 10.03439 15.65357 21.84208 29.76144 40.35457 ## 60% 70% 80% 90% 100% ## 54.82089 77.65199 119.08740 240.40789 27126.14108 11.3.2 Tableaux croisés Une variable Calculez le nombre de communes par type d’espace à l’aide de la fonction table, et le pourcentage associé t &lt;- table(df$ZAU2) t ## ## 111 112 120 211 212 221 222 300 400 ## 3285 12297 3962 456 815 888 582 7021 7383 100*prop.table(t) %&gt;% round(digits = 4) ## ## 111 112 120 211 212 221 222 300 400 ## 8.95 33.52 10.80 1.24 2.22 2.42 1.59 19.14 20.12 Deux variables t &lt;- table(df$REG,df$ZAU2) t ## ## 111 112 120 211 212 221 222 300 400 ## 01 17 6 1 0 0 3 0 2 3 ## 02 16 0 4 3 0 2 0 4 5 ## 03 3 3 0 2 0 1 0 0 13 ## 04 10 3 4 2 0 0 0 1 4 ## 11 413 853 3 3 2 0 0 7 0 ## 24 103 734 188 30 72 46 19 375 275 ## 27 140 1299 336 31 122 60 137 737 969 ## 28 216 1126 488 34 104 78 29 762 396 ## 32 481 1505 729 33 18 54 18 711 289 ## 44 322 1721 822 54 102 89 118 1155 815 ## 52 108 535 186 23 44 69 8 386 143 ## 53 89 415 152 47 18 42 1 325 181 ## 75 333 1161 254 51 81 163 81 1002 1379 ## 76 258 1124 333 79 155 123 89 877 1527 ## 84 548 1484 390 43 84 113 47 517 963 ## 93 220 229 69 20 11 32 6 107 269 ## 94 8 99 3 1 2 13 29 53 152 100*prop.table(t) %&gt;% round(digits = 4) ## ## 111 112 120 211 212 221 222 300 400 ## 01 0.05 0.02 0.00 0.00 0.00 0.01 0.00 0.01 0.01 ## 02 0.04 0.00 0.01 0.01 0.00 0.01 0.00 0.01 0.01 ## 03 0.01 0.01 0.00 0.01 0.00 0.00 0.00 0.00 0.04 ## 04 0.03 0.01 0.01 0.01 0.00 0.00 0.00 0.00 0.01 ## 11 1.13 2.32 0.01 0.01 0.01 0.00 0.00 0.02 0.00 ## 24 0.28 2.00 0.51 0.08 0.20 0.13 0.05 1.02 0.75 ## 27 0.38 3.54 0.92 0.08 0.33 0.16 0.37 2.01 2.64 ## 28 0.59 3.07 1.33 0.09 0.28 0.21 0.08 2.08 1.08 ## 32 1.31 4.10 1.99 0.09 0.05 0.15 0.05 1.94 0.79 ## 44 0.88 4.69 2.24 0.15 0.28 0.24 0.32 3.15 2.22 ## 52 0.29 1.46 0.51 0.06 0.12 0.19 0.02 1.05 0.39 ## 53 0.24 1.13 0.41 0.13 0.05 0.11 0.00 0.89 0.49 ## 75 0.91 3.16 0.69 0.14 0.22 0.44 0.22 2.73 3.76 ## 76 0.70 3.06 0.91 0.22 0.42 0.34 0.24 2.39 4.16 ## 84 1.49 4.04 1.06 0.12 0.23 0.31 0.13 1.41 2.62 ## 93 0.60 0.62 0.19 0.05 0.03 0.09 0.02 0.29 0.73 ## 94 0.02 0.27 0.01 0.00 0.01 0.04 0.08 0.14 0.41 Pour aller plus loin et ajouter des variables de pondération, calculer les profils-ligne ou profils-colonne, rendez-vous au module 3, ou demandez à votre GF (Gentil Formateur) 11.3.3 Les graphiques avec ggplot2 On reprend la base non filtrée. A l’aide de la cheat sheet ggplot2, réalisez un histogramme de la densite de population. ggplot(data = df,aes(x=densite)) + geom_histogram() Ce n’est pas très informatif, mais on peut faire une transformation log pour y voir plus clair ! ggplot(data = df,aes(x=log(densite))) + geom_histogram() Faites maintenant un barplot (qui n’est pas un histogramme !!!! ) du nombre de communes par type ZAU ggplot(data=df,aes(x=ZAU)) + geom_bar() On va essayer d’y voir plus clair avec le paramètre fill ggplot(data=df,aes(x=ZAU2,fill=ZAU2)) + geom_bar() Réalisez un graphique (unage de points) croisant la densité de population et le taux de mortalité ggplot(data=df,aes(x=densite,y=tx_mort)) + geom_point() On peut ajouter une dimension supplémentaire avec la couleur des points ggplot(data=df,aes(x=densite,y=tx_mort,color=ZAU2)) + geom_point() Là encore il faudrait faire une transformation logarithmique, mais tout ça est abordé dans le module 3 ! Avec les fonctions de base, on peut obtenir de nombreux graphiques avec très peu de code, mais moins jolis : plot(iris) Des possibilités infinies à approfondir dans les modules 3 et 5 !!!!! "],["exercices-pour-r-studio.html", "Chapitre 12 Exercices pour R Studio 12.1 Exercice 1 : Prendre en main RStudio (10 min.) 12.2 Exercice 2 : Faire ses premiers calculs (15 min.) 12.3 Exercice 3 : Créer ses premières variables (15 min.) 12.4 Exercice 4 : Créer son premier script (20 min.)", " Chapitre 12 Exercices pour R Studio 12.1 Exercice 1 : Prendre en main RStudio (10 min.) Depuis le gestionnaire de fichier de RStudio (panneau bas-droite), vous allez créer un dossier qui va servir de dossier de travail au cours de la formation. Pour cela : utilisez le bouton New folder (expl. Formation_R). Pour définir ce dossier comme répertoire de travail de R, sélectionnez-le et allez dans le menu More/Set as working directory. Regardez ce qui se passe dans la console (panneau bas gauche). Qu’est-ce que cela signifie ? Si vous voulez avoir plus de renseignements sur la fonction setwd, vous pouvez utiliser l’aide en ligne de R en écrivant ?setwd ou help(setwd) dans la console. Qu’est ce passe-t-il ? Dans l’onglet Help de RStudio, vous pouvez également faire une recherche à partir du moteur de recherche. Essayez d’obtenir des informations sur la fonction dir(). 12.2 Exercice 2 : Faire ses premiers calculs (15 min.) Dans la console, faite des calculs simples : 2 + 3, 5 * 4, 5 + (6 * 4), 2.5 * 1.3, 3**3 Que se passe-t-il lorsque vous écrivez pi dans la console ? Qu’est-ce que cela signifie ? Calculez maintenant cos(pi) et sin(pi/2). Que voyez-vous apparaître au moment où vous écrivez ces fonctions ? Faites maintenant la moyenne des nombres : 4, 5, 2, 1. Avez-vous utilisé un calcul ou une fonction de R ? Calculez la valeur absolue de l’opération 2 – 6. Calculez maintenant round(2.125412). Que voyez-vous ? Comment pouvez-vous faire pour faire un arrondi de 2.125412 à deux chiffres après la virgule (vous pouvez utiliser l’aide de R). Que se passe-t-il lorsque vous manipulez les flèches haut et bas depuis la console ? 12.3 Exercice 3 : Créer ses premières variables (15 min.) Dans la console, créer deux variables numériques a et b de valeur 5 et 4 par assignation : a&lt;-5 et b&lt;-4 Que se passe-t-il dans le panneau Environement (en haut à droite) ? Faites maintenant un calcul avec ces variables comme a+b et a*b. Vous allez ensuite créer une troisième variable à partir d’un calcul sur les deux premières : c&lt;-a+3*b Vous pouvez afficher la liste des variables avec la fonction ls(). Modifiez maintenant la valeur de a en lui donnant la valeur 10. Vérifiez votre ré-assignation dans la panneau Environement. Créez une variable chaîne de caractère : t&lt;-'texte' (vous pouvez également utiliser les doubles quotes comme “texte” mais ne les mélangez pas). Concaténez (mettez bout à bout) a et t avec la fonction paste(a,t). Que constatez-vous ? Pour plus de renseignements sur la fonction paste(), pensez à utiliser l’aide de R avec help(paste). Créez maintenant les variables A&lt;-15 et B&lt;-12. Que voyez-vous dans la panneau Environement ? Vous pouvez supprimer la variables A et B en utilisant la fonction rm() (utilisez l’aide de R pour avoir plus de renseignements sur la fonction rm). 12.4 Exercice 4 : Créer son premier script (20 min.) Depuis le panneau d’édition de script de RStudio (en haut à gauche), vous allez créer un script ré-utilisable permettant de calculer l’indice de masse corporelle d’un individu (IMC) et d’afficher le résultat dans la console sous la forme d’un phrase explicite. L’IMC est calculé par la masse sur la taille au carré d’un individu (\\(masse / taille^2\\)). Quelques petits conseils : de façon générale, n’hésitez pas à commenter votre script pour vous aider à le comprendre lorsque vous serez amené à le reprendre, pensez à bien assigner vos variables poids et taille pour une meilleure ré-utilisabilité du script, la fonction print() permet d’afficher une chaîne de caractères dans la console, pensez à arrondir le résultat de votre calcul d’IMC. Enregistrez ensuite votre script dans votre répertoire de travail. L’extension d’un fichier script pour R est .R. "]]
